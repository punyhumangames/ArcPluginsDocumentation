{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Welcome to the Arc Plugins documentation portal!</p> <p>Arc Plugins are a collection of plugins published by Puny Human on the Unreal Marketplace.  They are designed for multiplayer games across many genres, and built to empower developers to create amazing games without having to rewrite all the boilerplate for common systems.  They are all highly performant, shipping in multiple titles, and multiplayer focused.  </p>"},{"location":"#the-plugins","title":"The Plugins","text":"<ul> <li> Arc Inventory <p>Quote</p> Arc Inventory is a Gameplay Ability System based inventory solution that allows for the creation of ability-powered items and inventory management, and can slot seamlessly into your GAS-based game. Arc Inventory is built from the ground up for multiplayer, and supports everything from passive items, active items, stacking items, and more. Using Arc Inventory, you can create shooter gameplay, RPG gameplay, and even procedurally generate items or create an attachment system. <p>Unreal Marketplace \u2022 Documentation</p> </li> <li> Arc Teams <p>Quote</p> Arc Teams is a networked multiplayer solution that allows for the creation of Teams and other segmentation methods for players. Arc Teams was built from the ground up to support networked multiplayer games. It powers multiple games, each with different styles of segmenting players. ArcTeams supports both runtime and design time Team Definitions, allowing you to create any type of Team.  <p>Unreal Marketplace \u2022 Documentation</p> </li> </ul> <p>And more to come!</p>"},{"location":"arcactivities/","title":"Arc Activities","text":"<p>Unfinished Plugin</p> <p>Arc Activities is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>Arc Activities is a plugin that allows for gameplay scripting and a simple mission, quest, or activity flow.</p> <p>Designed for open world multiplayer or instance based missions.  Arc Activities features an \"Activity Graph\" asset that allows you to script your activity flow, progressing through \"Activity Stages\" and completing Objectives.  </p>"},{"location":"arcactivities/events/","title":"Activity Built in Event Reference","text":""},{"location":"arcactivities/events/#activity-state-changed-event","title":"Activity State Changed Event","text":"<p>Used for when activities start and end.</p> <ul> <li>Tag: <code>Activity.Event.StateChanged</code></li> <li>NativeTag: <code>FArcActivityStateChangedEventTag</code></li> <li>Struct: <code>FArcActivityActivityStateChanged</code></li> </ul>"},{"location":"arcactivities/events/#activity-stage-changed-event","title":"Activity Stage Changed Event","text":"<p>Used for when activities progress through stages</p> <ul> <li>Tag: <code>Activity.Event.StageChanged</code></li> <li>NativeTag: <code>FArcActivityStageChangedEventTag</code></li> <li>Struct: <code>FArcActivityStageChangedEventPayload</code></li> </ul>"},{"location":"arcactivities/events/#activity-player-changed-event","title":"Activity Player Changed Event","text":"<p>Used for when players join or leave activities</p> <ul> <li>Tag: <code>Activity.Event.PlayerChanged</code></li> <li>NativeTag: <code>FArcActivityPlayerChangedEventTag</code></li> <li>Struct: <code>FArcActivityPlayerEventPayload</code></li> </ul>"},{"location":"arccommunication/","title":"Home","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p>"},{"location":"arccommunication/#description","title":"Description","text":"<p>Arc Communication is a full featured text chat and voice chat suite for multiplayer video games on Unreal Engine.  Supporting multiple channels, user generated routing, and localized messages, Arc Communication can support all your communication needs in a multiplayer game.</p>"},{"location":"arccommunication/#technical-details","title":"Technical Details","text":""},{"location":"arccommunication/concepts/localizedmessages/","title":"Localized Messages","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>Localized Messages are Arc Communication's method for sending text and stylized messages to players.  All messages, from chat to a killfeed to player join/leave notifications to achievement toasts can be represented as a Localized Message.</p> <p>Localized Messages are a UObject that is created on the client per-message.  When a Client recieves a localized message, the Server sends it a Subclass of the localized message class and a struct of relevant information for that message.  The Client then constructs the localized message object and forwards it to UI for rendering. </p> <p>Localized Messages are intended to be subclassed in BP or C++ for a given message type.  Included in the Localized Message class is a UMG Widget subclass for rendering the Message (See User Interface for more information).  While Localized Messages can be rendered without a custom widget, creating a widget is what allows for styling and making Localized Messages look different from each other.</p>"},{"location":"arccommunication/concepts/localizedmessages/#sending-localized-messages","title":"Sending Localized Messages","text":"<p>Localized Messages can be sent to clients in many ways, from the client or the server.  </p> <p>The primary method is a player sending a Chat message to a Route, by way of the ArcCommComponent_Player.  This can be done with the <code>Chat [Channel] [Message]</code> console command, or called directly in C++ or Blueprint.  This will send a string to the server to act as a chat message, and will be sent back as a TextMessage object.</p> <p>The secondary method, if you wish to broadcast other types of messages, is to call <code>SendLocalizeddMessage</code> directly, with a Message, Route, and the message data.  This is a far more powerful method of sending message and crafting them to send, but may require some custom validation on the server.  This can be called in BP or C++</p> <p>From the server, you can broadcast messages from the ArcCommComponent_Gamemode.  If you simply wish to send an arbirtrary string, you can use <code>BroadcastTextMessage</code> to send a message from any sender.  Giving that function a PlayerState will imply that that player sent that text message.  </p> <p>If you want to send a custom message, you can use <code>BroadcastMessage</code>.  This can be called from BP or C++.  It requires formatting the message yourself, but gives full power when sending any message to clients, such as a kill feed, a Join/Leave message, or any other messages you wish to send.</p>"},{"location":"arccommunication/concepts/localizedmessages/#built-in-localized-messages","title":"Built in Localized Messages","text":"<p>Most messages will need to be defined for your implementation, but Arc Communication provides a few pre-made message types.  </p>"},{"location":"arccommunication/concepts/localizedmessages/#uarccommlocalmessage_textmessage","title":"UArcCommLocalMessage_TextMessage","text":"<p>Text Message is the main local message for player chat.  A valid Text Message subclass must be provided to the Game Mode Component so it can properly send text to clients in a chat context.</p>"},{"location":"arccommunication/concepts/localizedmessages/#uarccommlocalmessage_joinleavenotification","title":"UArcCommLocalMessage_JoinLeaveNotification","text":"<p>Not Implemented Yet</p> <p>The JoinLeave Notification message is sent whenever a player joins or leaves the server.  If the server doesn't have a valid JoinLeave notification message, it wont send the notifications to everyone.  </p>"},{"location":"arccommunication/concepts/routers/","title":"Routers","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>Routers are the primary object for sending message data to clients.  All messages, text or voice, are sent along a Route, and Routers must be set up to determine which clients will recieve anything pushed over that route.</p> <p>Routes are denoted by a <code>FGameplayTag</code>, and Routers determine which messages are handled through a <code>FGameplayTagQuery</code>.  Many Routers can apply to a single route, and messages are only sent over the Route if all Routers agree that a reciever can recieve a given message from a sender.</p> <p>Messages can be sent by any Actor in the scene.  When a message is sent by a Player, the Sender is that player's Player State.  This can be used to create a notification system or voice broadcasting system, in addition to player-sent chat.</p>"},{"location":"arccommunication/concepts/routers/#basic-setup","title":"Basic Setup","text":"<p>To add new routes for messages, you must add them to the Arc Communication Gamemode Component.  You can have any number of routes in the component, and can have multiple Tag Queries match the same route.  </p> <p>If multiple Route Queries match with a given message or VOIP broadcast, all Routers must agree that a given reciever can recieve that message.  If any Router denies the message to be sent to that client, the message is not sent to that client.  </p> <p>Note</p> <p>If a client is not eligible to recieve a message due to the router declining the message, the server will not send anything across the network to that client regarding that message.  A client may not recieve a message they sent themselves, if the route declines sending it back ot them.  Do not assume you will recieve a message.</p> <p>For example, if you wanted to create a set of routes [<code>Chat.All</code>, <code>Chat.Team</code>, <code>Chat.Announcements</code>], and have All and Team only be able to be sent messages by players and Announcement can only be sent to by the server, and have All and Announcements go to everyone, you would set up 4 routers:</p> <ul> <li>Router 1: ANY(Chat.All, Chat.Announcement), Router Class: ArcComRouter_All</li> <li>Router 2: ANY(Chat.All, Chat.Team), Router Class: ArcCommRouter_RequiresValidSender</li> <li>Router 3: ANY(Chat.Announcement), Router Class: ArcCommRouter_RequiresNoSender</li> <li>Router 4: ANY(Chat.Team) Router Class: YourCommRouter_Team</li> </ul> <p>The first router will route any messages sent to All and Announcements to everyone.  The second router will restrict the sender, requiring a valid player state to send to those routes.  Router 3 will prevent senders with a valid player state from sending to that route (thus requiring gameplay code to send it), and Router 4 is some hypothetical router that determiens if the sender and reciever are on the same team.  </p> <p>Such a router setup will also work for Voice channels.  </p>"},{"location":"arccommunication/concepts/routers/#built-in-routers","title":"Built In Routers","text":"<p>Arc Communication comes built in with a few routers to help get chat and voip working quickly.  You can create your own routers in C++ or Blueprint.  All built in routers work with Text or Voice.</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_all","title":"ArcCommRouter_All","text":"<p>The All router sends to every player on the server</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_requiresvalidsender","title":"ArcCommRouter_RequiresValidSender","text":"<p>The Requires Valid Sender router checks if the sender has a valid player state.  This is to validate that only players can send to this route.</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_requiresnosender","title":"ArcCommRouter_RequiresNoSender","text":"<p>The Requires No Sender router checks if the sender does not have a valid player state.  This is to ensure that players cannot send messages to this route, even if they want to.  Only gameplay code can send to this route, using an actor that is not a player.  See Sending Messages for more information.</p>"},{"location":"arccommunication/concepts/routers/#arccommrouter_proximity","title":"ArcCommRouter_Proximity","text":"<p>The Proximity router determines the distance between the sender and reciever, and if they are within a certain distance will send the message to that reciever.  The Proxmity Router determines the locations between any sender actor and the reciever.  </p>"},{"location":"arccommunication/concepts/ui/","title":"User Interface","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>To render localized messages and voip information, Arc Communication provides a number of built in UMG widgets to display text. </p> <p>Message rendering is split into two different parts, the Message View, and the Message Widget.  The View is a widget that holds a number of messages, while the Message Widget renders a Localized Message.</p> <p>Voip does Voip things when Voip is done.</p>"},{"location":"arccommunication/concepts/ui/#message-views","title":"Message Views","text":"<p>A Message View widget is a widget designed to display messages.  It implments the <code>BPI_LocalizedMessageViewReciever</code> interface.  The default implementation contains a FGameplayTagQuery used to determine if a View should recieve a message.  When received, the View Widget constructs a Message widget and applies the Localized Message to it.  </p> <p>You can implement your own \"meta view\" widget, that contains many children view widgets and implement the <code>BPI_LocalizedMessageViewReciever</code> interface on it.  From there, you can decide which view actually recieves the message.  </p>"},{"location":"arccommunication/concepts/ui/#messages","title":"Messages","text":"<p>A Message Widget is a widget that implements the <code>BPI_LocalizedMessageInterface</code> interface.  A classic chat message interface would display the Channel, the Sender, and the message.  A Message Widget can implement the display of the localized message however it wants, and is hosted in a view.  </p>"},{"location":"arccommunication/concepts/ui/#voip-notifications","title":"Voip Notifications","text":"<p>Not Implemented Yet</p>"},{"location":"arccommunication/concepts/voip/","title":"Voice","text":"<p>Unfinished Plugin</p> <p>Arc Communication is not finished.  Some features may be missing or unfinished.  Pardon the dust</p> <p>Not Implemented Yet</p>"},{"location":"arcinventory/","title":"Home","text":"<p>Welcome to the Arc Inventory documentation!</p>"},{"location":"arcinventory/#description","title":"Description","text":"<p>Arc Inventory is a Gameplay Ability System based inventory solution that allows for the creation of ability-powered items and inventory management, and can slot seamlessly into your GAS-based game. Arc Inventory is built from the ground up for multiplayer, and supports everything from passive items, active items, stacking items, and more. Using Arc Inventory, you can create shooter gameplay, RPG gameplay, and even procedurally generate items or create an attachment system.</p> <p>Arc Inventory is used in multiple games, and powers very different gameplay systems with this easy to use, designer focused system.</p> <p>Get it on the Unreal Marketplace: Marketplace Page</p>"},{"location":"arcinventory/#technical-details","title":"Technical Details","text":"<ul> <li>Inventory Components that support Bags, Equipment, and Active items.</li> <li>Fully integrated with Epic\u2019s Gameplay Ability System</li> <li>Supports Multiplayer</li> <li>Supports any game play mechanics GAS can do</li> <li>Easy to set up</li> <li>Requires minimal code</li> <li>Full Blueprint Integration</li> </ul> <p>Still need help?</p> <p>You can get support in our discord!</p> <p>Discord.gg/PunyHuman</p> <p>Plugin channels:</p> <ul> <li>#plugins-general</li> <li>#plugins-support</li> </ul>"},{"location":"arcinventory/deprecations/","title":"Deprecated Classes and Types","text":"<p>This page notes type and classes that have been deprecated, and will be removed.  If possible, a timeline for removal will be provided</p>"},{"location":"arcinventory/deprecations/#upcoming-removals","title":"Upcoming Removals","text":""},{"location":"arcinventory/deprecations/#arc-inventory-10-classes","title":"Arc Inventory 1.0 classes","text":"<p>Arc Inventory 2.0 features a vast array of new types and a far better system for creating items and storing data on items.  As such, a number of old '1.0' classes were kept around to assist in porting old data to the new modular system.</p> <p>The following files and classes are deprecated with the release of Arc Inventory 2.0, and will be deleted in Arc Inventory 2.3 (timeframe: around June 2023).  Please port your data over to the Modular Inventory classes if you rely on 1.0 classes.  </p> <ul> <li><code>Components/ArcInventoryComponent_Bag.h/.cpp</code></li> <li><code>Components/ArcInventoryComponent_Equipment .h/.cpp</code> </li> <li><code>Components/ArcInventoryComponent_Active .h/.cpp</code></li> </ul> <p>Info</p> <p>Replaced by the Modular Inventory Processors of the same names</p> <ul> <li><code>Generators/ArcItemGenerator_SimpleRandom .h/.cpp</code> </li> </ul> <p>Info</p> <p>Will be replaced and added to the Sample Project</p> <ul> <li><code>Generators/ArcItemGenerator_Unique .h/.cpp</code> </li> </ul> <p>Info</p> <p>Replaced by ArcItemGenerator_ModularUnique</p> <ul> <li><code>Item/ArcItemDefinition_New .h/.cpp</code></li> <li><code>Item/Definitions/ArcItemDefinition_Equipment .h/.cpp</code></li> <li><code>Item/Definitions/ArcItemDefinition_Active .h/.cpp</code></li> <li><code>Item/Perks/ArcItemDefinition_Perk .h/.cpp</code></li> <li><code>Item/Perks/ArcItemStack_Perk.h</code></li> </ul> <p>Info</p> <p>Replaced by the Modular Item Definitions and Fragments.  </p> <ul> <li><code>ArcItemStack .h/.cpp</code></li> </ul> <p>Info</p> <p>Replaced by ArcItemStackModular</p>"},{"location":"arcinventory/deprecations/#arc-inventory-plugin-blueprints","title":"Arc Inventory plugin blueprints","text":"<p>With the launch of Arc Inventory 2.0, we've begun keeping all supported versions of Arc Inventory up to date.  However, this has lead to maintenance issues with saving these assets with various engine versions.  </p> <p>In an effort to ease the upgrade path for these blueprints, they are being migrated to the Arc Inventory Example Project, where they can be easily migrated into your project.</p> <p>As such, the following blueprints are deprecated and will be removed in Arc Inventory 2.3 (timeframe: around June 2023).</p> <ul> <li>UI/BP_ArcInventoryUIFunctionLibrary</li> <li>UI/BP_BaseItemTooltip</li> <li>UI/BP_EmptyItemCard</li> <li>UI/BP_ItemSlotDragAndDrop</li> <li>UI/BP_ItemSlotReference</li> <li>UI/BP_ItemSlotWidget</li> <li>UI/wooden-crate</li> <li>UI/Examples/BP_InventoryBagWidget</li> <li>UI/Examples/ItemCards/BP_SimpleItemUIData</li> <li>UI/Examples/ItemCards/BP_SimpleLargeItemCard</li> <li>UI/Examples/ItemCards/BP_SimplePerkItemCard</li> <li> <p>UI/Examples/ItemCards/BP_SimpleSmallItemCard</p> </li> <li> <p>Abilities/BP_DropItemFromSlotNew</p> </li> <li>Abilities/BP_LootAllTheThings</li> <li> <p>Abilities/BP_SwapItemSlots</p> </li> <li> <p>Input/ArcInvInputBinder_Raw</p> </li> </ul> <p>All of these files will be located in the Arc Inventory Example project, and the most recent engine versions (starting with 5.1) will be tagged.  </p>"},{"location":"arcinventory/faq/","title":"FAQ/Common Issues","text":""},{"location":"arcinventory/faq/#crashdisconnect-in-multiplayer-when-swapping-items-switching-items-or-using-any-of-the-built-in-inventory-abilities","title":"Crash/Disconnect in Multiplayer when swapping items, switching items, or using any of the built in Inventory abilities.","text":"<p>This crash often accompanies the error in your log. <pre><code>LogAbilitySystem: Error: Could not find GameplayAbilityTargetData_ItemSwitch in ScriptStructCache\nLogAbilitySystem: Error: Could not script struct at idx 2\n</code></pre></p> <p>This is caused by failure to init the Gameplay Ability System Globals.  You need to call <code>UAbilitySystemGlobals::InitGlobalData()</code>  The Arc Inventory Example Project contains a useful Engine Subsystem for this.  You can grab the Engine Subsystem from a github gist as well.</p> <p>You can find out more information in the community GAS documentation about Initing the Ability System.</p>"},{"location":"arcinventory/faq/#are-there-any-debug-overlays-or-tools-to-help-see-the-internal-state-of-the-inventory","title":"Are there any Debug overlays or tools to help see the internal state of the inventory?","text":"<p>There are!  Simply use the console command <code>ShowDebug Inventory</code> to view the internal state of the inventory.  This will display a list of all item slots for you.  </p> <p>If you want to see all of the items, set <code>ArcInventory.DebugDetailedItemInfo 1</code> in the console.  This will show detailed slot info and any detailed debug information for the item that is in that slot.  It's disabled by default (as the text can get very cluttered).</p>"},{"location":"arcinventory/initialsetup/","title":"Initial Setup","text":"<p>Thanks for purchasing Arc Inventory!  Once you've downloaded the plugin and enabled it in your project, this is how you start to use it!</p> <p>Info</p> <p>This plugin uses a lot of other Unreal Engine concepts to achieve full functionality.  It's recommended that you have a firm grasp on Unreal Engine, GAS, and Gameplay Tags</p> <ul> <li>GASDocumentation</li> <li>Unreal Engine Gameplay Tag documentation</li> </ul>"},{"location":"arcinventory/initialsetup/#adding-the-plugin-to-your-project","title":"Adding the plugin to your project","text":"<p>There are two methods to add the plugin to your project, one for if you use the Epic provided launcher build, and one if you use a github source build</p> Launcher BuildSource Build <p>The Unreal Engine launcher will place the plugin in the Engine/Plugins/Marketplace folder.  For a majority of people this is ideal.  ArcInventory will automatically activate.</p> <p>If you wish to make custom modifications to ArcInventory, it is recommend you copy the plugin out of the Engine/Plugins/Marketplace folder and place it in your game's Plugins/ directory.      </p> <p>If using a source build from github or Epic's perforce, you must first download the plugin from the Unreal Engine marketplace.  You must have a launcher version installed to download it for that engine version, but you don't need to use it.</p> <p>Once downloaded, you need to copy the plugin from your Engine/Engine/Plugins/Marketplace folder and place it in your game project's Plugins/ folder.  </p> <p>After that, Arc Inventory should build and be available to your game.</p> <p>Note</p> <p>For a C++ project, you need to add ArcInventory to your game module's build.cs file.  Simply add <code>\"ArcInventory\"</code> to the <code>PublicDependencyModuleNames</code> in your game module's .build.cs file.  </p>"},{"location":"arcinventory/initialsetup/#optional-configuring-the-asset-manager","title":"Optional: Configuring the Asset Manager","text":"<p>Arc Inventory supports the Asset Manager to dynamically load items!  To set that up, you simply need to configure the Primary Asset Types for the Arc Inventory types.</p> Editor.ini <p>In the Unreal Editor, go to View -&gt; Project Settings.  Select the Asset Manager category within Game.</p> <p>Add two entries in the <code>Primary Asset Types to Scan</code> array, and set them to be the following information:</p> <p></p> <p>In your <code>DefaultGame.ini</code>, add the following tags to the <code>[/Script/Engine.AssetManagerSettings]</code> section (Create it if it doesn't exist)</p> <pre><code>+PrimaryAssetTypesToScan=(PrimaryAssetType=\"ArcItemGenerator\",AssetBaseClass=/Script/ArcInventory.ArcItemGenerator,bHasBlueprintClasses=True,bIsEditorOnly=False,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\n+PrimaryAssetTypesToScan=(PrimaryAssetType=\"ArcInventoryModularItemDef\",AssetBaseClass=/Script/ArcInventory.ArcInventoryModularItemDef,bHasBlueprintClasses=false,bIsEditorOnly=False,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\n</code></pre> <p>Note</p> <p>When to load asset data and best practices around the Asset Manager is out of scope for this documentation, but for development it is often easy to just load all assets of these types at game startup.  </p>"},{"location":"arcinventory/updateto2/","title":"Understanding and Upgrading to Arc Inventory 2.0","text":"<p>So you're working on a project that is upgrading from Arc Inventory 1.0 to 2.0.  2.0 involves a very significant data layout change for Item properties and data, and is a bit of a change in how things operate.  </p> <p>Arc Inventory 2.0 makes use of a Modular Inventory system.  This document will go over the changes, the rational, how to approach development using these modular pieces, and some tips and tricks to update 1.0 code to 2.0 code.</p>"},{"location":"arcinventory/updateto2/#modular-inventory-101-fragments-and-processors","title":"Modular Inventory 101 - Fragments and Processors","text":"<p>The core change from Arc Inventory 1.0 is a transition from a polymorphic inheritance based system for item data to a modular, data oriented system based around Fragments and Processors.</p> <p>In Arc Inventory 2.0, Item Fragments are given to Items to track data, and Inventory Processors are given to an inventory component to make the items do things.  </p> <p>Note</p> <p>Almost every inventory function now returns a <code>UArcItemStackBase*</code> instead of <code>UArcItemStack*</code> (which is now just for 1.0 item stacks).  This is for compatibility between 1.0 systems and 2.0 systems.  It is best to cast it to a <code>UArcItemStackModular*</code> and use the item stack that way.  <code>UArcItemStackBase*</code> does not have Item Definitions or Stack sizes.  </p> <p>Warning</p> <p>The change to <code>UArcItemStackBase*</code> may prevent your code from compiling or inventory functions from working as before, and you may have to update your code to <code>ArcItemStackBase</code>.  Arc Inventory 2.0 is NOT compatible with ArcInventory 1.0 data.  Classes and data remain only to help port data from 1.0 to 2.0.  </p>"},{"location":"arcinventory/updateto2/#modular-inventory","title":"Modular Inventory","text":"<p>You will have to migrate all Inventory components to <code>UArcInventory_Modular</code>.  This is the primary inventory component for ArcInventory 2.0, and where all functionality derives.  </p> <p>If your actors use the <code>UArcInventory</code> base class for holding the inventory component as outlined in the SimpleFPS tutorial for ArcInventory 1.0, in C++ you can use <code>ObjectInitializer.SetDefaultSubobjectClass&lt;UArcInventoryComponent_Modular&gt;(InventoryComponentName)</code> in your constructor to change the subclass to the Modular Inventory.  </p> <p>Warning</p> <p>Unreal Engine 5.0 has a bug where simply changing the component from the 1.0 inventory subclass to the Modular Inventory causes data corruption in blueprint.  It is recommended you back up any blueprint when transitioning to the new class.  We've found that setting the inventory component property to BlueprintReadWrite and then setting the component to None, and then back to Modular Inventory allows the blueprint to work.  However, this causes data loss.  It is recommended that you copy, screenshot, or otherwise store your custom item slots and active inventory settings before migrating to Modular Inventory.  </p> <p>The bug has been reported to Epic.   </p>"},{"location":"arcinventory/updateto2/#item-fragments","title":"Item Fragments","text":"<p>Item Fragments are a UObject based object that are instanced either on an Item Stack or an Item Definition.  There is an API (<code>FindFragment</code> or <code>FindAllFragments</code>) on the ItemStack to access a given Item Fragment, and that function can pull from either the Item Definition or the Item Stack itself.</p> <p>For example:</p> <p>A gun would have an Item Definition with a number of fragments that define the behaviors of the gun, such as what abilities are granted to the player, what it looks like, what sounds it makes, damage, etc.  </p> <p>When that gun is generated, a Rarity Fragment and Name fragment are created and placed onto the Item Stack.</p> <p>When some code that cares about the item queries for data, it uses <code>FindFragment</code> to search up that information and use it.  </p> <p>Fragments of the same type and tags can exist on both the Item Stack and the Item Definition, and the Item Stack's version will be returned instead of the Definition's version.  This lets us override elements of an item on a per-item basis.</p>"},{"location":"arcinventory/updateto2/#item-processors","title":"Item Processors","text":"<p>Item Processors listen to events on the inventory and do things when those happen.  For example, the Active processor will listen for when items are placed into active item slots, and it manages which items are active.</p> <p>Item Processors can be considered as components of an inventory.  </p>"},{"location":"arcinventory/updateto2/#other-changes","title":"Other changes","text":"<p>Bits of data that can be represented as an Integer are now stored in a tagged data stack.  For example, Stack Size is now stored there.  One could also implement something like Durability this way as well.</p>"},{"location":"arcinventory/updateto2/#item-generators","title":"Item Generators","text":"<p>There is a new Item Generator, the Modular Unique generator.  This functions nearly identically to the Unique item generator (producing a single item with specific settings), however it uses the modular item definitions and can place Fragments directly onto an item stack.  </p> <p>Otherwise, the Item Generator system hasn't changed much.</p> <p>Note</p> <p>There is no 2.0 version of the Simple Random Item Generator yet.  It will be added in a future update. </p>"},{"location":"arcinventory/updateto2/#updating-10-items-to-20-items","title":"Updating 1.0 Items to 2.0 Items","text":"<p>Arc Inventory 2.0 comes with a helpful script that converts 1.0 items to 2.0 items.  Simply right click on an Arc Inventory 1.0 item definition, select \"Scripted Actions\" and choose \"Convert Old Item Definition to Modular\".  This will create a <code>Convert/</code> folder in the directory of that item and port all the data in that old item definition into a new item definition.</p> <p>Note</p> <p>The Conversion script is located in the Arc Inventory Sample Project.  Copy the script to your own project, and make modifications to support your own data.  </p> <p>If you change the way it ports data, simply re-run it over items that have already been converted and it will update already created modular item definitions with new fragments.  </p>"},{"location":"arcinventory/updateto2/#creating-new-items","title":"Creating New Items","text":"<p>When creating a new type of item, care should be taken to consider what the item needs to be functional.  A simple item needs a Static Mesh fragment with the <code>Item.Fragment.World</code> tag, it needs a Text fragment with the <code>Item.Fragment.Name</code> tag, and probably a UI icon in the form of a Texture fragment with the <code>Item.Fragment.UI.Icon</code> tag.  Beyond that, consider the functionality of the item and what fragments already exist to provide it.  Don't be afraid to add as many fragments as you need!  </p> <p>If you need to create a fragment, try to break the fragment definition down into as many reusable parts as possible.  For example, Scopes can have one or two attachments, so creating a fragment for \"Attachment\" and distinguishing them using tags is ideal. </p> <p>Fragments can also be added to an item dynamically at runtime.  This is very useful if you need to store complex data on an item, such as an item that tracks a PlayerState or the applied abilities for an Ability Info fragment.  For many items, you may want to add dynamic fragments at item generation time, or in other cases, you may want to add things to an item when it's placed in a slot in the inventory (by way of an Item Processor). </p> <p>An item does not have to have an Item Definition.  This should be a rare case, but creating a fully dynamic item with fragments is entirely possible!  It is very hefty on replication load, but if you have cool ideas in this space, don't hesitate to explore them (Please report any performance issues on Discord).  </p>"},{"location":"arcinventory/usefulresources/","title":"Useful Resources","text":"<ul> <li>GASDocumentation</li> <li>Unreal Engine Gameplay Tag documentation</li> </ul>"},{"location":"arcinventory/1.0/initialsetup/","title":"Initial Setup","text":"<p>Thanks for purchasing Arc Inventory!  Once you've downloaded the plugin and enabled it in your project, this is how you start to use it!</p> <p>Info</p> <p>This plugin uses a lot of other Unreal Engine concepts to achieve full functionality.  It's recommended that you have a firm grasp on Unreal Engine, GAS, and Gameplay Tags</p> <ul> <li>GASDocumentation</li> <li>Unreal Engine Gameplay Tag documentation</li> </ul>"},{"location":"arcinventory/1.0/initialsetup/#optional-configuring-the-asset-manager","title":"Optional: Configuring the Asset Manager","text":"<p>Arc Inventory supports the Asset Manager to dynamically load items!  To set that up, you simply need to configure the Primary Asset Types for the Arc Inventory types.</p> Editor.ini <p>In the Unreal Editor, go to View -&gt; Project Settings.  Select the Asset Manager category within Game.</p> <p>Add two entries in the <code>Primary Asset Types to Scan</code> array, and set them to be the following information:</p> <p></p> <p>In your <code>DefaultGame.ini</code>, add the following tags to the <code>[/Script/Engine.AssetManagerSettings]</code> section (Create it if it doesn't exist)</p> <pre><code>+PrimaryAssetTypesToScan=(PrimaryAssetType=\"ArcItemGenerator\",AssetBaseClass=/Script/ArcInventory.ArcItemGenerator,bHasBlueprintClasses=True,bIsEditorOnly=False,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\n+PrimaryAssetTypesToScan=(PrimaryAssetType=\"ArcItemDefinition_New\",AssetBaseClass=/Script/ArcInventory.ArcItemDefinition_New,bHasBlueprintClasses=True,bIsEditorOnly=False,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\n</code></pre> <p>Note</p> <p>When to load asset data and best practices around the Asset Manager is out of scope for this documentation, but for development it is often easy to just load all assets of these types at game startup.  </p>"},{"location":"arcinventory/1.0/initialsetup/#for-ue-426-configuring-arc-inventory","title":"For UE 4.26, Configuring Arc Inventory","text":"<p>Note</p> <p>As of Unreal Engine 4.27, Configuring Arc Inventory is no longer needed.  If you use previous version of Arc Inventory, this section is still necissary.</p> <p>Your first step will be to configure the necissary tags for Arc Inventory's internal functions.  These are required, and many features will fail to function if these tags are not configured.  </p> Editor.ini <p>In the Unreal Editor, go to View -&gt; Project Settings.  Select the Arc Inventory Developer Settings category within Game.</p> <p></p> <p>Deprecation Notice</p> <p><code>Ability Tag Mappings</code> is deprecated and unused.  It will be removed in future versions of Arc Inventory</p> <p>in <code>DefaultGame.ini</code> the you can configure the following fields with tags:</p> <pre><code>[/Script/ArcInventory.ArcInventoryDeveloperSettings]\nEquippedSlotTag=(TagName=\"Inventory.Slot.Equipment\")\nActiveItemSlotTag=(TagName=\"Inventory.Slot.Active\")\nBagItemSlotTag=(TagName=\"Inventory.Slot.Bag\")\nItemSlotSwapAbilityTags=(GameplayTags=((TagName=\"Ability.Inventory.SwapItemSlot\")))\nItemSlotDropAbilityTags=(GameplayTags=((TagName=\"Ability.Inventory.DropItems\")))\n</code></pre> <p>Warning</p> <p>Ensure that the tags are defined in your <code>GameplayTags.ini</code> or however else you've configured gameplay tags!</p> <p>Once the tags are configured, the Plugin is setup and ready to go!  You are ready to add the Inventory Component to your player!</p>"},{"location":"arcinventory/1.0/concepts/generators/","title":"Item Generators","text":"<p>Item Generators are the factory that produces items.  Because of the need to create Item Stacks and associate them with Item Definitions, It becomes fairly involved to create new items on demand.  Item Generators seek to bridge that gap and allow control over the item production process.</p> <p>Most games will not need to use Item Generators.  It is very common for a game to create a single Item Generator, set the Item Definition for it to spawn, and then spawn that item.  This is perfectly fine, and it is recommended for most games starting out using the system.  The Example Project uses this method to generate items.  </p> <p>However, if you need more control over the process of creating items, Arc Inventory gives you a lot of it.</p>"},{"location":"arcinventory/1.0/concepts/generators/#basic-setup","title":"Basic Setup","text":"<p>Item Generators require subclassing UArcItemGenerator and overriding the <code>GenerateItemStack_Implementation</code> function.  This can be done in Blueprint.   </p> <p>Inside that function, you simply need to return a <code>UArcItemStack</code> pointer.  Most item generators will call <code>CreateNewItemStack</code> with the Definition and an optional rarity, do some work on the item stack, and then return it.  </p> <p>Tip</p> <p>You can create as many item stacks as you need in a single generator, which is useful for generating SubItems to attach to your item!</p> <p>Arc Inventory contains a few built in item generators, including a Static Item Generator class for embedding into property editors, and a Unique Item Generator for customizing all of the components of item generation in the property editor.  </p>"},{"location":"arcinventory/1.0/concepts/generators/#procedural-generation","title":"Procedural Generation","text":"<p>Arc Inventory also supports the procedural generation of items through Item Generators.  Included in the plugin is a Simple Random generator that produces 'Perks' and attaches Sub Items to items, based on item rarity.  </p> <p>The Simple Random generator uses a weighted random algorithm to determine how common certain elements are, and uses child item generators to produce sub items that are attached to the parent item, with a number based on the rarity.  </p> <p>Simple Random is intended to be an example.  While projects may use it, Procedural Generation of items is generally a game specific mechanic, and it's advised that you create your own generator for procedural generation.</p>"},{"location":"arcinventory/1.0/concepts/highlevel/","title":"High Level","text":"<p>At the highest level, Arc Inventory is an inventory that allows you to power your game code with GAS, and to give you a lot of power over the design and development of your game.</p> <p>The Inventory System's primary purpose is to give your character and pawns a set of Gameplay Effects, Abilities, and Attributes, and control how and when those are added to and removed from your character's ASC.</p>"},{"location":"arcinventory/1.0/concepts/highlevel/#project-goals","title":"Project Goals","text":"<p>Arc Inventory has a few goals, and they are reflected in every part of the inventory system.</p> <ol> <li> Don't Assume Game Design Arc Inventory will not assume your design or make design choices for you.  The core structure can be reused across many genres of game, from RPGs to FPSes to Survival games to Action RPGs. Inventory accomplishes this by breaking up different inventory concepts across the system and classes.  </li> <li> Let the user subclass Arc Inventory attempts to be a general base for GAS powered inventory, but because of #1, it does not make a lot of game design choices like Input or complex UI.  Because of this, every part of the system is intended to be subclasses to fill out features.   </li> <li> The Character Does the Work Arc Inventory makes the character do the work, and is intended to be a component on your character.  Items, ItemDefs, and all pieces are simply bits of information for your character to react to.  Things like how your character actually holds the item or what happens when you activate an item is easily scripted, but must be done on the character or inside of an Gameplay Ability. </li> </ol>"},{"location":"arcinventory/1.0/concepts/highlevel/#inventories","title":"Inventories","text":"<p>Inventories are the primary container for Items.  Inventory is an actor component that handles the placement of items into Slots.  The Inventory has many subclasses to enable different types of functionality, and care should be taken to decide which class is right for your game.</p> <p>At it's core, Inventories are an array of <code>Inventory Slots</code>.  Slots are defined with a set of Gameplay Tags, and can have an Item Filter to indicate which items can be placed into the slot.  </p> <p>Inventory Slots are split into 3 different concepts, <code>Bag</code>, <code>Equipment</code>, and <code>Active</code>.  </p> <code>Bag Slot</code> Bag Slots are slots that can generally hold any item, but do not do anything when an item is placed into them.   <code>Equipment Slot</code> Equipment Slots are slots that generally hold specific items, and place GAS primitives onto the component owner when the item is put into the slot.   <code>Active Slot</code> Active slots are slots that hold specific items, and only one item can be active at a time of all items in active slots.  These can be thought of as held items for a first person shooter or a sword that the player is currently wielding. <p>Tip</p> <p>A slot can be any combination of <code>Bag</code>, <code>Equipment</code>, or <code>Active</code>.  It's very common for Active Slots to also be Equipment Slots!</p> <p>Caution</p> <p><code>Equipment</code> and <code>Active</code> slots only have meaning when using their corrisponding subclass of UArcInventoryComponent.  See the Inventory page for more details!</p>"},{"location":"arcinventory/1.0/concepts/highlevel/#items","title":"Items","text":"<p>Items are split into two different concepts, the <code>Item Stack</code> and the <code>Item Defininition</code>.  </p> <code>Item Stack</code> A Replicated UObject that contains instance-specific data for a given item.  It's very light and thin to support many items being replicated <code>Item Definition</code> A default-object only blueprint class that contains all of the static data for each item. <p>These concepts are split to allow Item Stack to be as light as possible with replication.  </p> <p>Info</p> <p>It is intended that you subclass both <code>UArcItemStack</code> and <code>UArcItemDefinition</code> for your custom implementations</p>"},{"location":"arcinventory/1.0/concepts/highlevel/#item-generators","title":"Item Generators","text":"<p>Item Generators are factories for creating items.  An item generator can be as simple as just tying together an Item Definition or as complex as procedurally generating an item with multiple prefixes, suffixes, and random stats.  </p>"},{"location":"arcinventory/1.0/concepts/inventory/","title":"Inventory","text":"<p>Inventory is the primary container for items, and the primary controller for what items do to players.  </p> <p>Inventory is implemented as an Actor Component, and has many children classess to cover different gameplay functions.  The base class, <code>UArcInventoryComponent</code> features the core slot structure, placing items into slots, and allowing developers to understand the layout of their inventory through queries.  </p>"},{"location":"arcinventory/1.0/concepts/inventory/#base-inventory","title":"Base Inventory","text":"<p>The Primary mechanism for the base inventory is to manage and replicate Slots.  It also watches if items move in those slots, and handles the insertion and removal of items</p> <p>The underlying data layout is hidden from implementors, and the public API handles all edge cases around Replication, Ownership, and reports back failure states.</p> <p>Warning</p> <p>If a function returns a bool, that means that it can fail.  It is up to you to determine how to handle that failure.  Not catching failure states can lead to Items being lost!</p>"},{"location":"arcinventory/1.0/concepts/inventory/#slots","title":"Slots","text":"<p>Slots are the primary container for items.  The underlying replication type, <code>FArcItemSlot</code> is not exposed to the public API, but it covers the details of replication and ensuring that slots are synchronized between client and server.  The public API exposes a <code>FArcItemSlotReference</code>, which contains a all the data needed to reference a slot in an inventory.  All functions that refer to inventory slots take a <code>FArcItemSlotReference</code>, and for all purposes, that is the item slot.  </p> <p>Note</p> <p>Always check if the slotref is valid before attempting to access it or pass it into an inventory.  </p> <p>Warning</p> <p><code>FArcItemSlotReference</code> contains a weak pointer to the owning inventory.  If that inventory is destroyed, the slotref will be invalid.  It is not recommend that you store a slotref across multiple frames.  It is recommend that you either strongly control the data lifetime, or query for the slot when you need it.  </p>"},{"location":"arcinventory/1.0/concepts/inventory/#slot-queries","title":"Slot Queries","text":"<p>Slot Queries are the concept for access data inside of an inventory.  They are represented by <code>FArcInventoryQuery</code>.  They have two properties, <code>ItemTypeQuery</code> and <code>SlotTypeQuery</code>.  Item Query functions are generally prefixed with <code>Query_</code>, and the different Query functions allow accessing different types of slots. </p> <p>ItemType and SlotType can be used interchanably.  ItemType looks for the item in the slot and matches tags on the item's tags.  ItemType queries automatically fail on slots that are empty.  SlotType Query searches the tags on each slot.    </p>"},{"location":"arcinventory/1.0/concepts/inventory/#slot-filters","title":"Slot Filters","text":"<p>Slot Filters allow designers to indicate what items can be placed into the slot.  Slot Filters contain a GameplayTagQuery to search the tags on a given item, and whether or not to force that slot to contain a single stack.  If there is no TagQuery, the slot accepts all items.</p>"},{"location":"arcinventory/1.0/concepts/inventory/#notable-functionsproperties","title":"Notable Functions/Properties","text":"<ul> <li> <code>CustomInventorySlots</code> An EditDefaultsOnly Array of Item Slot definitions.  This is where you design out all your slots that have custom functionality.  It is very common to have a dozen or more slots defined here.   </li> <li> <code>CreateInventorySlot</code> / <code>RemoveInventorySlot</code> Protected runtime creation of inventory slots.  It's protected so you can access these by subclassing your inventory, but allows you to create and remove item slots.  Everything replicates fine when creating and removing slots.   </li> <li> <code>PlaceItemIntoSlot</code> Places an item into a slot.  Will fail if the slot already has an item. Always check the return value of this function, and handle failure accordingly.  It is common to call LootItem if PlaceItemIntoSlot fails.  </li> <li> <code>LootItem</code> Places an item into the first slot it can.  The order it checks slots is not garuanteed, so it could end up in slots you don't expect.  If it fails, that means that item cannot possibly fit into the inventory, and failure should be handled. </li> </ul> <p>Caution</p> <p>If placing an item into a slot succeeds, it is recommend to discard the pointer to the item you currently have.  Internally, the Inventory will remap the owner of the items, sometimes Duplicating the object (this is to deal with problems with Unreal Replication).  </p>"},{"location":"arcinventory/1.0/concepts/inventory/#bag","title":"Bag","text":"<p>Bag is the first subclass of the base inventory.  Bag inventory creates a number of \"Bag Slots\", which are slots without item filters.  The number of bag slots can be 0.  You can also bind the number of slots to a Gameplay Attribute to change the number of bag slots at runtime.  </p> <p>Tip</p> <p>If you bind the bag slot gameplay attribute, you can change that attribute with an item!  </p>"},{"location":"arcinventory/1.0/concepts/inventory/#equipment","title":"Equipment","text":"<p>Equipment slots are slots with the Equipment tag as defined project settings.  When an item is placed into this slot, a callback will fire indicating that the item is equipped.  If your item has an item definition derived from <code>UArcItemDefinition_Equipment</code>, then it will activate the equipped item information and placed the GAS primitives on the player.</p> <p>Tip</p> <p>Use Equipment slots to hold things like armor in an RPG game, skills in a Overwatch-style hero shooter or MOBA, or stat-stick weapons in a Diablo or Path of Exile style Action RPG!</p>"},{"location":"arcinventory/1.0/concepts/inventory/#active","title":"Active","text":"<p>Active Inventories are inventories with a set of slots defined with the Active Slot tag.  In an active inventory, only one slot can be active at a time, and when that slot is active a callback is issued.  If an item is in the slot with a definition that derives from <code>UArcItemDefinition_Active</code>,  then the GAS Primitives in the Active Item Info property will be applied to the character.</p> <p>Tip</p> <p>Use Active Inventories for FPS or RPG games where your character can only hold one item at a time!</p> <p>Info</p> <p>If these subclasses do not support your game type, it is easy to extend an inventory component and add your own functionality.  Most games create their own Inventory Component with their own functionality when items are placed into certain slots!</p>"},{"location":"arcinventory/1.0/concepts/itemstack/","title":"Item Stacks","text":"<p>The second concept is the Item Stack, or Item Instance.  Item Instancing can get very heavy with a lot of data, and Arc Inventory takes care to make each item as light as possible, while still being extendable.  To achieve this, Arc Inventory creates two concepts for storing item data, the Stack and the Definition.  The Item Stack is the per-instance data, and only data that is necessary is included in it.  The Item Definition is the static data that doesn't change across instances, like the abilities an item grants or it's mesh.  </p> <p>The difference between an Item Stack and an Item Definition is important and a key concept to understand with Arc Inventory</p> <p>Tip</p> <p>It is possible and intended to extend both Item Stack and Item Definition.  Extending Item Definition to add your own static data is extremely common.  Extending ItemStack is less common, but if you need to replicate per-instance data, it can be easily done.</p>"},{"location":"arcinventory/1.0/concepts/itemstack/#item-stacks","title":"Item Stacks","text":"<p>Item Stacks are derived directly from UObject, and are replicated inline with the inventory (or other replicated actor who owns the stack).  Item Stacks are extremely thin, and only replicate and contain necessary information for the instance of the object.  The contain the full representation of an item, including the item definition</p> <p>Warning</p> <p>Internally, Item Stacks are duplicated or moved around, so a pointer to an item stack may expire when transferring items across inventories.  This is to help better support replication, but does mean that it's required to discard pointers to items when transferring item stacks or merging them.</p> <p>Item Stacks can have a stack size, meaning multiple items of the same definition can be combined into one single object.  They can be merged and split, creating new item stack objects in the process.  The Item Definition must allow items to do this, and two item stacks with different sub-items cannot be merged.</p> <p>Item Stacks also hold instanced attribute sets for the instanced attribute system.  When the inventory needs to store off attributes or active gameplay effects, it does so by storing them in the Item Stack.</p>"},{"location":"arcinventory/1.0/concepts/itemstack/#sub-item-stacks","title":"Sub Item Stacks","text":"<p>Item Stacks can contain a list of Item Stacks as \"Sub Items\".  These are fully functional items with definitions that are attached to the parent item.  Sub Items can be nested indefinitely.  This can be used to create a component system. </p> <p>Sub Items are replicated inline, and every item can have different sub items.  They are ideal for replicating option information with certain item instances.  </p> <p>Tip</p> <p>Use Sub Item Stacks to implement perks, attachments, or even firing modes on your items!</p>"},{"location":"arcinventory/1.0/concepts/itemstack/#item-definitions","title":"Item Definitions","text":"<p>Item Definitions are the static data for items.  They are used as class definitions and CDOs only, never instanced.  In this regard, they can be very lightly replicated, and are key to high performance in the system.</p> <p>Item Definitions carry all of the data required to make the item work.  They are often subclassed to add more data depending on the usage of that item, and easily support all kinds of data.  Different subclasses of the Inventory Component do work with the data in an Item Definition to achieve functionality.</p> <p>Note</p> <p>It is the Inventory that applies GA primitives to the character.  The Item Definition simply contains that data.  </p>"},{"location":"arcinventory/1.0/concepts/itemstack/#world-stacks","title":"World Stacks","text":"<p>Given that Item Stacks and Item Definitions are not actors, Items cannot be placed in the game world.  Since this is a common need for inventory systems, Arc Inventory contains a class, <code>AArcItemStackWorldObject</code>, which implements basic replication and visuals for an item. </p> <p>It is recommended that you set up a subclass of this actor, and override the setting in the Project Settings to use it.  You can use <code>UArcItemBPFunctionLibrary::SpawnWorldItem</code> or the <code>Spawn World Item</code> function in blueprint to spawn World Items easily.  </p> <p>Tip</p> <p>If you want different items to behave differently when spawned into the world, you will need to spawn the World Stack yourself, and call <code>SetInventoryStack</code> on it with the item stack you wish to assign.</p>"},{"location":"arcinventory/1.0/concepts/ui/","title":"User Interface","text":"<p>User Interface is a common requirement for Inventory systems, but often requires unique and game specific implementations to achieve the best look.  To this end, Arc Inventory provides a few building blocks for development inventories, but expects that user implement their own stylized views.  </p> <p>Arc Inventory follows the MVC pattern for UX, with Inventory/Items acting as the Model, UMG Widgets acting as the View, and Game Framework code like Pawns, the Inventory Component, and Player Controllers acting as the Controller.</p> <p>Tip</p> <p>While you are welcome to modify all of the UMG widgets inside of the Plugin, it is recommended that you copy them out into your own project.  Plugin Updates may overwrite any changes you make.</p>"},{"location":"arcinventory/1.0/concepts/ui/#ui-data","title":"UI Data","text":"<p>Item Specific UI Data is stored in a blueprintable <code>UIData</code> instanced object inside of the Item Definition or Item Generator.  Both ItemDef and ItemGen have this object, as it allows you display item generators to the user if your game design requires it.</p> <p>UI Data objects can be easily extended in blueprint to add new properties.  It is common to create multiple types of UIData structures for different items.  UMG widgets can access this object and cast to whichever child class is needed to display it.</p> <p>Warning</p> <p>UI Data is not replicated!  If there are specific properties you wish to replicate to display on the UI, it must be replicated in the Item Stack.</p>"},{"location":"arcinventory/1.0/concepts/ui/#item-slot-widget","title":"Item Slot Widget","text":"<p>Item Slot Widgets are the primary method for showing the contents of an item slot.  Item Slot Widgets can query for a given slot based on some query, or can be given a SlotRef directly on construction.  Once bound to an item slot, it will display the contents of that slot.</p> <p>Info</p> <p>Provided is an example Bag widget, which fills the widget with Item Slot Widgets equal to the number of slots in a bag inventory, and bound to those slots.  It's a good reference for dynamically creating Slot Widgets!</p>"},{"location":"arcinventory/1.0/concepts/ui/#item-cards","title":"Item Cards","text":"<p>Items are displayed using an 'Item Card' widget, or a specific UMG subclass that contains a reference to an item and displays the information within that card.  By default, there are two types of Item Cards, Small and Large.  Small Item Cards are generally a 32x32 image displaying the item on top of the item slot widget or while dragging and dropping.  Large Item Cards are used to display the item when you mouse over the Item Card, and often contain all of the data.  The Item Cards look into the Item's UI Data for textures and names to use. </p> <p>It is up to the implementer to create their own displays, but some examples are provided in the plugin.  </p>"},{"location":"arcinventory/1.0/concepts/ui/#drag-and-drop","title":"Drag and Drop","text":"<p>Item Slot Widgets implement drag and drop behaviors, allowing for easy swapping of item slots by simply dragging the item to another slot widget.  This is done by way of calling an ability on the player by a tag as defined in the project settings.  </p> <p>Tip</p> <p>More information is located in the Manipulating Items tutorial!</p>"},{"location":"arcinventory/1.0/integrations/moveit/","title":"MoveIt","text":""},{"location":"arcinventory/1.0/integrations/moveit/#what-is-moveit","title":"What Is MoveIt?","text":"<p>MoveIt's Marketplace Description</p> <p>MoveIt! is a semi-procedural locomotion system for Unreal Engine 4 featuring full network replication and easy integration. MoveIt! is aimed at all game types, and works especially well with shooters or melee games that are camera-facing.</p> <p>MoveIt! was spawned from a need for high quality, replicated, and performance focused locomotion that simply did not exist. Very clean, easy to use, well documented and works flawlessly in multiplayer while being built on top of a solid foundation allowing for on-going updates and improvements.</p> <p>MoveIt! also utilizes multi-threaded animation which is very rare with marketplace assets, and will allow you to have more characters with better performance!</p> <p>You can acquire it here on the Unreal Marketplace</p>"},{"location":"arcinventory/1.0/integrations/moveit/#project-setup","title":"Project Setup","text":"<p>To begin integration, ensure that MoveIt is setup according to their documentation</p> MoveIt 1.xMoveIt 2.x <p>MoveIt Project Setup</p> <p>Documentation is not released yet</p> <p>Warning</p> <p>Ensure that <code>\"MoveIt\"</code> is part of your PublicDependencyModuleNames in your build.cs!</p>"},{"location":"arcinventory/1.0/integrations/moveit/#subclassing-itemdef","title":"Subclassing ItemDef","text":"<p>Once we've set up MoveIt, it's time to integrate arc inventory.</p> <p>First, we are going to create a new Subclass of <code>UArcItemDefinition_Active</code>, and add MoveIt's <code>FMIWeapon</code> structure to it</p> <pre><code>UCLASS()\nclass MYGAME_API UMyItemDefinition_Active : public UArcItemDefinition_Active\n{\n    GENERATED_BODY()\npublic:\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = \"Attachment\")\n    FMIWeapon WeaponAttachData;\n};\n</code></pre> <p>Compile that, and then launch your editor.  </p> <p>From there, Create a new Blueprint based on <code>UMyItemDefinition_Active</code>, name it <code>BP_MyMoveItItem</code>.  Save this item</p> <p>Tip</p> <p>If you already have an item, you can simply reparent already existing items to this new class</p> <p>From there, configure the <code>Weapon Attach Data</code> field, but leave <code>Weapon Mesh</code> as None.</p> <p>Note</p> <p>MoveIt ships with a Rifle and Pistol animation pose and offset.  Your own custom animations can be placed here, but that is beyond the scope of this tutorial.</p> <p>For more information, refer to the MoveIt Weapon Documentation</p>"},{"location":"arcinventory/1.0/integrations/moveit/#setting-up-the-player","title":"Setting Up the Player","text":"<p>In your Character blueprint, create a new Variable named <code>WeaponInfo</code> of type <code>MI Weapon</code>.  This will be where we store the Weapon Info struct from the item.</p> <p>Also, in your character blueprint, Create a new Skeletal Mesh component as a child of Mesh.  Name it <code>Held Item Mesh</code>.  </p> <p>From there, Select your Inventory Component, and scroll to the Events section.  Press the big green button for \"On Item Active\" and \"On Item Inactive\" to bind a blueprint function to these events.</p> <p>In your OnItemActive handler, cast the <code>Item Stack</code> to <code>MyItemDefinition_Active</code>.  Call <code>Get Class Defaults</code> on the resulting struct to grab the Weapon Attach Data.  Set your Character's <code>Weapon Info</code> variable to be that attach data.  </p> <p></p> <p>Also, in this handler, grab the Held Item Mesh from the class (you may have to select the Get Class Defaults pin and delect it in the details editor) and assign it to your HeldItemMesh component's mesh.</p> <p>in the OnItemInactive handler, simply set MI Weapon to be an empty struct, and set your HeldItemMesh's mesh to empty.</p> <p>Finally, in Functions, hit Override and override the function <code>Get Weapon Anim Info</code>.  In there, drag in a getter for your <code>WeaponInfo</code> struct and right click on it, select 'Split Struct Pin'. Drag off from <code>Weapon Info Weapon Pose</code> an Is Valid check.  If it is not valid, simply return an empty struct.  If it is valid, create a new Return node, and right click on that and Split Struct Pin.  Connect all the pins from your class's weapon struct to the return node's pins, except the <code>Return Value Weapon Mesh</code> which should be linked to your <code>Held Item Mesh</code> component.</p> <p></p>"},{"location":"arcinventory/1.0/integrations/moveit/#conclusion","title":"Conclusion","text":"<p>That is it!  MoveIt will now properly animate your character to hold the weapon.</p>"},{"location":"arcinventory/1.0/tutorials/containers/","title":"Maniuplating Items inside and outside of your Inventory","text":""},{"location":"arcinventory/1.0/tutorials/containers/#swapping-slots","title":"Swapping Slots","text":"<p>The Primary method to swap items is to activate the built in Swap Item Slots Ability.  This is stored in the ArcInventoryContent folder in your content browser.  </p> <p>Note</p> <p>If you do not see it, you will need to click the little eyeball and enable \"Show Plugin Content\" and \"Show Engine Content\"</p> <p>Swapping Items is done by setting, on the client, the <code>SwapToSlot</code> and <code>SwapFromSlot</code> on the Inventory component, and then activating the ability.  The Ability will then synchronize the FromSlot and ToSlot to the server, and execute the <code>SwapItemSlots</code> function.  This is predicted on the local client, so feedback is instant.</p> <p>Note</p> <p>The default Item Slot Widget will try to activate abilities by the Swap Item Slot tag in the Project settings.  If you cannot get item swapping working, check that your character has that ability, and that tag is set in the project files, and that tag is part of the Ability Tags in the Swap Item Slot ability.  </p> <p>If you are writing your own UI, it is recommended that you set the <code>SwapToSlot</code> and <code>SwapFromSlot</code> properties and then call the ability.  </p> <p>Tip</p> <p>It is recommended that you copy the Swap Item Slots ability out of the plugin and into your project.  Games may need more rules around swapping item slots, and modifying an asset in the plugins folder can be dangerous.</p> <p>You can also create your own SwapItemSlots ability if you want to use your own replication method</p>"},{"location":"arcinventory/1.0/tutorials/containers/#dropping-items","title":"Dropping Items","text":"<p>Included in the plugin is an ability that will drop an item from an item slot.  This Ability handles all dropping of items by replicating the slot to the server, removing the item from the inventory in that slot, and then spawning a \"World Item\" with that stack as part of it (See Item Stack Concepts for more information).</p> <p>The removal of items from your inventory is not predicted.  In high latency environments, you will have a delay between the user attempting to drop the item, and the item being removed from the inventory and spawning in the world.   </p> <p>Note</p> <p>The Default Item Slot Widget will attempt to drop an item into the world if the drag and drop operation ends without an underlying Item Slot Widget.  This is done by activating any ability on the owning character with the <code>Item Slot Drop Ability Tags</code>.  As with Swapping, ensure that your character has this ability, that tag is set in the project settings, and the ability has it in it's Ability Tags.</p> <p>If you are writing your own UI, it's recommended that you set the <code>PendingItemDrop</code> property in Inventory and call the ability by tag.  </p> <p>Tip</p> <p>As with the Swap Item Slots ability, it is recommended that you copy this ability out of the plugin and into your project.</p> <p>Also as with the Swap Item Slots ability, you can create your own if you need to.</p>"},{"location":"arcinventory/1.0/tutorials/containers/#pick-up-an-item","title":"Pick up an item","text":"<p>Picking Up an item is not provided by default in Arc Inventory</p> <p>There are many methods to achieve this, but I will do a simple one for this tutorial that is not predicted.</p> <p>In your character blueprint, Bind an event to <code>Input E</code>.  Create another event called <code>TryPickupItem</code>.  Set it to Run On Server, and check the Reliable button.  Call <code>TryPickupItem</code> in the Pressed event from Input E.  </p> <p></p> <p>In TryPickupItem, call <code>Line Trace By Channel</code>.  Set the Start point to be your Camera's world location and the end point to be some point 400 units in front of the camera, using the forward vector from the character's aim angles.  Set your character to be an Ignore actor.  </p> <p></p> <p>Check the results of this line trace.  If we hit a target, break the hit result and grab the actor.  Cast it to Arc <code>Inventory World Stack Actor</code>.  Grab the item stack in it and call <code>Loot Item</code> on our Inventory with that item stack.</p> <p></p> <p>If the item was successfully looted, Destroy the World Stack Actor.  </p> <p>You now have the item in your inventory.</p> <p>Tip</p> <p>This process can be put into an ability, and every part can be predicted, except for the destroying the world stack actor.  </p>"},{"location":"arcinventory/1.0/tutorials/containers/#create-a-container","title":"Create A Container","text":"<p>Any Actor can hold an Inventory Component.  Item Stashes or Chests are a good example of an actor that can hold many items.</p>"},{"location":"arcinventory/1.0/tutorials/containers/#create-a-container-actor","title":"Create a Container Actor","text":"<p>To Start, Create a new Actor, which we will call <code>BP_ItemChest</code>.  Give that Actor some visuals (a white Cube will suffice) and a Bag Inventory component.  Give the Bag 12 slots.</p> <p>Warning</p> <p>In Multiplayer, ensure that the actor replicates and the inventory component replicates!</p> <p>Place this actor in the world.  This is our stash that will hold our items.  </p>"},{"location":"arcinventory/1.0/tutorials/containers/#create-a-view-widget","title":"Create a View Widget","text":"<p>Now, we need to be able to inspect it.  We must create a UMG widget to view this container.  Create a new widget that we'll call <code>WBP_ChestView</code>.  Lay out the widget however you want, but I went with a simple black border.  </p> <p>In the content of the widget, Add in a <code>BP_InventoryBagWidget</code> to your widget.  This widget will display the contents of any Bag Inventory.  </p> <p>Tab over to the Graph for the widget, and create a new variable of type <code>ArcInventoryComponent_Bag</code> and name it <code>Target Bag</code>.  Check <code>Instance Editable</code> and <code>Expose on Spawn</code>.</p> <p>In the Construct node, set the InventoryBagWidget's <code>Bag Inventory</code> property to your newly created variable.  This will target the bag view to look at whichever target we give it.</p> <p></p> <p>Info</p> <p>I also added a \"Close\" button to my widget, that removes the widget from parent.  You may want to control interaction differently.</p>"},{"location":"arcinventory/1.0/tutorials/containers/#interaction","title":"Interaction","text":"<p>Next, we need to interact with a chest to view it's contents.  In your player, create a new input button for viewing the widget.  Similar to the Pickup Item, we need to line trace forward to see if we are looking at a chest.</p> <p>Do what you did for line tracing, but this time cast to <code>BP_ItemChest</code></p> <p></p> <p>Once you have the chest, get it's bag inventory component and create a <code>Create Widget</code> node.  Set the class to <code>WBP_Chest View</code>, set the owning player to our player controller, and set the <code>Target Bag</code> to the Chest's bag component.  Add this component to viewport, and then activate the mouse cursor.</p> <p> </p> <p>You should now see the contents of the chest!</p>"},{"location":"arcinventory/1.0/tutorials/containers/#transfer-items-between-two-inventories","title":"Transfer Items between Two Inventories","text":"<p>Note</p> <p>This feature requires ArcInventory 1.2.3 or greater.  </p> <p>Simply dragging the item between your inventory and the target inventory should work via Drag and Drop.</p> <p>The Inventory takes any two inventory slots to transfer items to/from.  So long as one of the slotrefs reference a slot in the player's inventory, it will swap between the two inventories.  </p> <p>Caution</p> <p>The default implementation does not check if a player should be transferring items between two inventories.  It is up to you to implement these checks</p>"},{"location":"arcinventory/1.0/tutorials/randomitems/","title":"Simple Random Items","text":"<p>For many games, Randomizing stats and abilities on items is an important and fun part of the game.  Games such as Path of Exile, Diablo, Borderlands, Destiny, and many others.  Arc Inventory supports creating randomized items, but setting up the gameplay elements to make it fun is a bit of effort.  This tutorial will cover the basics of how to set up randomized items, weapon/armor slots, granting abilities, and putting items in the correct slots in the UI.  </p> <p>It is expected that you have a basic character setup, as outlined in the GAS Documentation.  Also, a review of the high level concepts is recommended before launching into this tutorial.  This Tutorial will also be in C++ and Blueprint.  </p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#part-1-setup-the-inventory","title":"Part 1: Setup the Inventory","text":"<p>In your player pawn, Implement the <code>IArcInventoryInterface</code> from \"Interfaces/ArcInventoryInterface.h\".  Do so like this:</p> <p>YourCharacter.h <pre><code>UCLASS()\nclass YOUR_API AYourCharacter : public ACharacter, public IArcInventoryInterface /* ASC Interfaces here too */\n{\n    //Your character class stuff...\n\nprivate: \n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\n    class UArcInventoryComponent* InventoryComponent;\npublic:\n    static FName InventoryComponentName;\n\n    class UArcInventoryComponent* GetInventoryComponent() const override { return InventoryComponent; }\n};\n</code></pre></p> <p>YourCharacter.cpp <pre><code>    FName AYourCharacter::InventoryComponentName(TEXT(\"InventoryComponent\"));\n\n    AYourCharacter::AYourCharacter(const FObjectInitializer&amp; ObjectInitializer)\n        : Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UArcInventoryComponent_Active&gt;(InventoryComponentName))\n    {\n        InventoryComponent = CreateDefaultSubobject&lt;UArcInventoryComponent&gt;(InventoryComponentName); \n\n    }\n</code></pre></p> <p>Note</p> <p>This setup, with the <code>static FName InventoryComponentName</code> and <code>SetDefaultSubobjectClass</code> allows you to have a bit of a heirarchy for your character classes.  For example, you can have a base class that uses a basic inventory component and a 'PlayerCharacter' subclass that has an Active inventory component.  It is up to you if you want to go this route.</p> <p>Next, create a new Blueprint Class that is a child of <code>AYourCharacter</code>, named BP_YourCharacter.  Verify that you have an Inventory Component on your character.</p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#attribute-set-setup","title":"Attribute Set Setup","text":"<p>We now need to create some GAS types, an Attribute set and a pair of abilities.  The Attribute Set will be modified by our items, and the abilities will be granted by them.  </p> <p>To get started, lets create an Attribute Set, which we will call AMyAttributeSet.  Lets give it two attributes, Armor and Power, which we will modify by our randomized items.  You will easily be able to create additional attributes for your game, but to keep this tutorial simple we are going to just make two.  </p> <p>In your editor project, go to <code>File</code>, then <code>New C++ Class</code>.  Check \"Show All Classes\", and select <code>Attribute Set</code> as the parent class.  Name it <code>MyAttributeSet</code> and hit Create Class.  If it asks to edit the class, hit yes.</p> <p>From here, we need to add in our C++ code for this attribute set.  For this, we need to write a bit of boilerplate code, which you can find out more about in the GAS Documentation </p> <p><code>MyAttributeSet.h</code> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AttributeSet.h\"\n#include \"MyAttributeSet.generated.h\"\n\nUCLASS()\nclass UMyAttributeSet : public UAttributeSet\n{\n    GENERATED_BODY()\npublic:\n    UMyAttributeSet(const FObjectInitializer&amp; ObjectInitializer);\n\n    virtual void GetLifetimeReplicatedProps(TArray&lt;class FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;\n\n    UPROPERTY(Category = \"Attributes\", EditAnywhere, BlueprintReadOnly, ReplicatedUsing = OnRep_Power)\n    float Power;\n\n    UFUNCTION()\n    virtual void OnRep_Power(float PreviousPower);\n\n    UPROPERTY(Category = \"Attributes\", EditAnywhere, BlueprintReadOnly, ReplicatedUsing = OnRep_Armor)\n    float Armor;\n    UFUNCTION()\n    virtual void OnRep_Armor(float PreviousArmor);\n\n};\n</code></pre></p> <p><code>MyAttributeSet.cpp</code> <pre><code>#include \"MyAttributeSet.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"AbilitySystemComponent.h\"\n\nUMyAttributeSet::UMyAttributeSet(const FObjectInitializer&amp; ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n    Armor = 30;\n    Power = 100;\n}\n\nvoid UMyAttributeSet::GetLifetimeReplicatedProps(TArray&lt;class FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n{\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Power, COND_None, REPNOTIFY_Always);\n    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Armor, COND_None, REPNOTIFY_Always);\n}\n\nvoid UMyAttributeSet::OnRep_Power(float PreviousPower)\n{\n    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Power, PreviousPower);\n}\n\nvoid UMyAttributeSet::OnRep_Armor(float PreviousArmor)\n{\n    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Armor, PreviousArmor);\n}\n</code></pre></p> <p>Now that we've created this attribute set, let's add it to our character's Ability System Component.  In our <code>BP_YourCharacter</code>, access the Ability System Component.  Find the <code>Default Starting Data</code> property, and an add an element to that array.  In the Attributes drop down, select our Attribute Set we just created.  Leave Default Starting Table blank.  </p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#simple-ability-setup","title":"Simple Ability Setup","text":"<p>From there, we need a simple ability. For this tutorial, we are just going to create a simple ability that prints out our attributes.  This ability can do whatever we want, but creating gameplay mechanics is a bit outside the scope of this tutorial.  </p> <p>In your content browser, right click, select <code>Gameplay</code> and chose <code>New Gameplay Ability Blueprint</code>.  Select <code>Gameplay Ability</code> from the Parent Classes dialog, and name this ability <code>BP_PrintAttributes_GPA</code>.</p> <p>This ability will be simple.  We are going to get the value of the <code>Armor</code> and <code>Power</code> attributes, and then when we activate our ability it will print the values to the screen.  </p> <p></p> <p>Once we have this ability set up, save it and compile.  </p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#randomized-items","title":"Randomized Items","text":"<p>Arc Inventory was originally designed to support randomized items, and accomplishes this through the use of Sub Item Stacks on a given item, and an Item Generator to produce the Item Stack.  </p> <p>In this tutorial, we are going to take advantage of some of the example randomization code provided in the plugin, but we will go into some detail about the structure and how to create your own classes or modify them for your game.  </p> <p>To create a randomized item, we need to have an Item Generator that can support randomization.  For most games, Item Generation produces a rather simple item stack, but for randomization, we need to produce not just an 'base' item stack for the item, we need to also create and attach the randomized properties for the item as well.  In Arc Inventory, we have created a \"Simple Random\" item generator that uses a weight-based randomization algorithm to select the randomized properties to give to an item.  </p> <p>However, we are going to create our own simple randomizer that will select one random property from a list and add it to our item stack as a perk.  </p> <p>So, lets get started creating a Item Generator.  Just like the attribute set, let's create a new C++ class for <code>MyItemGenerator</code>.  In the Create New C++ Class dialog, view all classes and select <code>ArcItemGenerator</code> as the base class.  </p> <p>In the Header, we need to override the <code>GenerateItemStack_Implementation</code> function, the base item definition, and create an array of attribute modifiers.  We will use the Arc Inventory provided <code>FArcPerkModifierData</code> type, which allows us to select and modify a gameplay attribute.  The Item Generator will select a random Modifier and add it to the the item we are creating. </p> <p><code>MyItemGenerator.h</code></p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Generators/ArcItemGenerator.h\"\n#include \"Perks/ArcItemPerkTypes.h\"\n#include \"MyItemGenerator.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass ARCINVENTORYEXAMPLE_API UMyItemGenerator : public UArcItemGenerator\n{\n    GENERATED_BODY()\npublic:\n\n    virtual UArcItemStack* GenerateItemStack_Implementation(const FArcItemGeneratorContext&amp; Context) override;\n\n    //The base item definition that we will be randomizing\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Definition\")\n    TSubclassOf&lt;UArcItemDefinition_New&gt; ItemDefinition;\n\n    UPROPERTY(EditDefaultsOnly, Category=\"Randomization\")\n    TArray&lt;FArcPerkModifierData&gt; PossibleModifiers;\n\n};\n</code></pre> <p>Let's implement GenerateItemStack_Implementation now.  </p> <p>The first thing we want to do is generate the base item as normal.  To do that, we simply need to call <code>CreateNewItemStack</code> with the Item Definition we are creating.</p> <pre><code>UArcItemStack* UMyItemGenerator::GenerateItemStack_Implementation(const FArcItemGeneratorContext&amp; Context)\n{\n    UArcItemStack* BaseItem = CreateNewItemStack(ItemDefinition, nullptr);\n\n    //Randomize the Item\n\n    return BaseItem;\n}\n</code></pre> <p>Note</p> <p>We aren't using Rarities in this tutorial, so the second parameter of CreateNewItemStack will always be nullptr.</p> <p>Now, we need to randomize the item.  Again, for this tutorial, we are just going to select one randomization and apply it to our item here.  Let's select a random element from the randomization array, and create a new item from it.  We will be using the built in 'Perk' item stacks.  </p> <pre><code>UArcItemStack* UMyItemGenerator::GenerateItemStack_Implementation(const FArcItemGeneratorContext&amp; Context)\n{\n    UArcItemStack* BaseItem = CreateNewItemStack(ItemDefinition, nullptr);\n\n    //Select a random perk\n    int32 index = FMath::RandHelper(PossibleModifiers.Num());\n\n    FArcPerkModifierData RandomModifer = PossibleModifiers[index]; //Copy this modifier out of the possibles\n\n    RandomModifer.Value = FMath::RandRange(1, 50); //Create a random value for this modifier\n\n    UClass* PrevISC = ItemStackClass;\n    ItemStackClass = UArcItemStack_Perk::StaticClass();\n\n    if (UArcItemStack_Perk* NewPerk = Cast&lt;UArcItemStack_Perk&gt;(CreateNewItemStack(UArcItemDefinition_Perk::StaticClass(), nullptr)))\n    {   \n        NewPerk-&gt;Modifiers.Add(RandomModifer); //Add the modifier to the perk\n        //Add the random perk to the base item\n        BaseItem-&gt;AddSubItemStack(NewPerk);\n    }\n    ItemStackClass = PrevISC;\n\n    return BaseItem;\n}\n</code></pre> <p>Note</p> <p>Normally, you would have a custom Item Generator for perks here.  Because this is a simple tutorial with only one item generator, we need to set the ItemStackClass before calling CreateNewItemStack.  If you want to use the multiple item generator strategy, you can see it in <code>ArcItemGenerator_SimpleRandom.cpp</code></p> <p>Now, we have an Item Generator that is capable of generating a randomized item.  </p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#inventory-setup-and-item-creation","title":"Inventory setup and Item Creation","text":"<p>Note</p> <p>This section is taken from the Simple FPS tutorial.  If you've done that tutorial already, you can skip this part</p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#inventory-layout","title":"Inventory Layout","text":"<p>Arc Inventory makes a very clear distinction between underlying data and the visual representation of that data.  This allows for seperation of work for larger teams, but also for quick iteration of doing temp UI to get design down.  </p> <p>We'll start with adding item slots.  Our goal will be to create an inventory layout similar to the screenshot on the marketplace for Arc Inventory.  For that, we have the following:</p> <ul> <li>Primary Weapon</li> <li>Secondary Weapon</li> <li>Head Armor</li> <li>Body Armor</li> <li>Passive Slot 1</li> <li>Passive Slot 2</li> <li>N Bag slots</li> </ul> <p>The Primary Weapon and Secondary Weapon slots can hold Active Items (IE: weapons that can be held in the character's hand), and for the sake of this tutorial, we'll say that only Pistols can go in the Secondary Weapon slot and any active items can go into primary.  Head and Body armor require items that fit directly in that slot, but Passives can hold any passive item except Head and Body armor.  N Bag Slots means that you have any number (lets say 12) slots that can hold any item, but if the item is in that bag slot it does nothing. </p> <p>Open BP_Character and navigate to the Inventory Component on it.  There, you will see 'Bag Slot Count'.  Set that to 12 (Note, you can bind it to a GameplayAttribute, and the bag will resize as that attribute changes).  This gives us N Bag Slots.</p> <p>From there, in the Inventory Layout section, Create 6 array elements.  These will be our custom slots.</p> <p>In slot 0, we want to have a primary weapon.  So, in the Tags, Give the slot the Active item tag and the Equipment tag (Ensure you set these in the Arc Inventory settings in the project settings).  This will denote this slot as both an Active and Equipment slot, and those behaviors will activate when an item is placed into this slot.  We also want to indicate that this is the 'Primary Weapon' slot, so create a new tag <code>Inventory.Slot.PrimaryWeapon</code> and give it to this slot.  </p> <p>In this slot's filter, we want to create Filter Query that accepts <code>ANY(Inventory.ItemType.Weapon)</code>, and check 'Force Single Stack'.  This will cause the Inventory to check if any item attempting to be placed into this slot contains the <code>Inventory.ItemType.Weapon</code> tag, and it will only accept items with 1 stack.  We'll set the items up later.  </p> <p>Secondary Weapon is similar to Primary weapon.  Give it the Active and Equiment tags, and create a tag named <code>Inventory.Slot.SecondaryWeapon</code> and grant it.  In the filter, create a query that checks for the <code>Inventory.ItemType.Weapon.Pistol</code> tag to ensure that only pistols can be placed in this slot.  </p> <p>For Head and Body Armor, we want to set the Tags to be have the Equipment Tag, and a tag for it's name (ie <code>Inventory.Slot.HeadArmor</code>).  In the Filter, Ensure that the query is looking for <code>ANY(Inventory.ItemType.Passive.Head)</code> and Body respectively.  We also want to force single stack.</p> <p>The passive slots are similar, however they do not need unique tags to identify them.  Give them the Equipment Tag, and give them both the <code>Inventory.Slot.Passive</code> tag, and ensure that their filters only allow passive items (perhaps <code>ANY(Inventory.ItemType.Passive) AND NOT(Inventory.ItemType.Passive.Head OR Inventory.ItemType.Passive.Body)</code>)  Slots do not need unique tags, and since any valid item can be placed in either slot.  If we wish to find specific items later in code, we can query for different information.  </p> <p>With this, the data is set up for this inventory layout.  Now lets create a few items to put into these slots</p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#creating-some-items","title":"Creating Some Items","text":""},{"location":"arcinventory/1.0/tutorials/randomitems/#weapons","title":"Weapons","text":"<p>Create a new Blueprint Class that inherits from UArcItemDefinition_Active.  Active Item Definitions are item definitions that denote items that can be held in a player's hand.  Active Items can be placed into any slot, but they only can become active if placed in a slot with the Active Item tag, and the player makes that item active (usually through swapping to that item).</p> <p>In the Owned Tags variable, set the containter to have <code>Inventory.ItemType.Weapon.Rifle</code>, and any other tags you wish to describe this weapon.  I have seen setups with 10+ tags to describe each weapon, and there is very little cost to having many tags on a weapon.</p> <p>In Active Item Ability Info, Set up the Active Ability Entry, by giving it an ability and bind it to input.  See GAS Documentation for methods for doing input.  Add any Attribute Sets you want to this item as well, and any tags that are granted to the player.  Anything defined and set up in Active Item Ability Info is only applied to the character when the item is held in the character's hand.  </p> <p>Once you are happy with this item, Duplicate this item and change it's Owned Tag to have <code>Inventory.ItemType.Weapon.Pistol</code>.  This will go in the secondary slot.  </p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#equipment","title":"Equipment","text":"<p>Similar to weapons we want to create some new blueprint classes here.  Unlike weapons, we want to create these based on UArcItemDefinition_Equipment.  While Active items inherit from Equipment (and have many of the same properties), by inheriting from Equipment you cannot make these items active if they are in an active item slot, and thus cannot be held in hand.  </p> <p>In our Owned Tags, we want to give our equipment some tags to describe the item.  we created a few tags when we created the item slots, so make sure you use those tags to describe head and body armor.</p> <p>In the Equipped Item Ability Info, give these Head and Body armor pieces an 'Added Gameplay Effects' entry and give them a gameplay effect that is applied to the character when these items are placed into a slot with the Equipment tag.  This is done automatically.  </p>"},{"location":"arcinventory/1.0/tutorials/randomitems/#generating-items","title":"Generating Items","text":"<p>Now that we have some items and an item generator for them, now we must put these two parts together to create items.  In the editor, create a new blueprint based on MyItemGenerator.  We will need to create an Item Generator for each type of item we are making, so expect to make a few of these.  For this tutorial though, we will create one and leave the rest as an exercise for the user.  </p> <p>In the first Generator, we will give it the Rifle as our base item type.  We'll also create two modifiers, one for Power and the other for Armor.  </p> <p>In the <code>Item Definition</code> property, set it to your first item Definition.  In the <code>Possible Modifiers</code> property, create two array elements, setting the first to <code>MyAttributeSet.Power</code> and the econd to <code>MyAttributeSet.Armor</code>.  Leave both of them as the <code>Add</code> op and the Value to 0.0 and slot application to an empty query (we will not be using this). </p> <p>Note</p> <p>In the item definition for the item you are using as the base item, ensure that the \"Print Ability\" ability is the active item bound to input.</p> <p>Now, in our character's starting item generators, we will use this item generator to produce an item.  Set the starting item generator to use your this BP_MyRandomGenerator, and when the game starts up you will have a randomized item.  If you activate the print ability, you will see that the properties have been randomly modified by the perk.  </p> <p>Note</p> <p>Consult the example project for how to set up a character with starting item generators.</p> <ul> <li>Item Drops</li> <li>Pickup into inventory</li> </ul>"},{"location":"arcinventory/1.0/tutorials/randomitems/#configuring-the-ui","title":"Configuring the UI","text":"<ul> <li>Item Slot Views</li> <li>Item Cards</li> <li>Perk Views</li> </ul>"},{"location":"arcinventory/1.0/tutorials/simplefps/","title":"Arc Inventory Tutorial","text":"<p>How to create a simple Active and Equippable Inventory</p>"},{"location":"arcinventory/1.0/tutorials/simplefps/#part-0-setup-arc-inventory","title":"Part 0: Setup Arc Inventory","text":"<p>This Tutorial assumes you've setup the inventory plugin and have it working.  It also assumes you have some form of Ability for a weapon.  You can use the FPS shoot ability from the example.</p> <p>This Tutorial assumes you have a Player Pawn and the Ability System is setup for it.  Refer to the GASDocumentation by tranek for tips and strategies to set that up.</p> <p>This Tutorial assumes you are familair with Gameplay Tags and Gameplay Tag Queries.  Please refer to the Unreal Engine Gameplay Tag documentation for more information.</p> <p>For the UI Section of the tutorial, it assumes you are very familiar with UMG.  </p> <p>This Tutorial uses a mix of C++ and Blueprint.  C++ code will be denoted by a C++ code block like so:</p> <pre><code>Code()\n</code></pre> <p>No C++ code is gauranteed to compile or work.  Examples are for illustration of the point.</p> <p>Blueprint will be described (may add images later).</p> <p>Note</p> <p>Ensure that in the Arc Inventory Settings in the Project Settings, appropriate tags are set for the Bag Slot, Equipment Slot, and Active slot. </p>"},{"location":"arcinventory/1.0/tutorials/simplefps/#part-1-setup-the-inventory","title":"Part 1: Setup the Inventory","text":"<p>In your player pawn, Implement the <code>IArcInventoryInterface</code> from \"Interfaces/ArcInventoryInterface.h\".  Do so like this:</p> <p>YourCharacter.h <pre><code>UCLASS()\nclass YOUR_API AYourCharacter : public ACharacter, public IArcInventoryInterface /* ASC Interfaces here too */\n{\n    //Your character class stuff...\n\nprivate: \n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\n    class UArcInventoryComponent* InventoryComponent;\npublic:\n    static FName InventoryComponentName;\n\n    class UArcInventoryComponent* GetInventoryComponent() const override { return InventoryComponent; }\n};\n</code></pre></p> <p>YourCharacter.cpp <pre><code>    FName AYourCharacter::InventoryComponentName(TEXT(\"InventoryComponent\"));\n\n    AYourCharacter::AYourCharacter(const FObjectInitializer&amp; ObjectInitializer)\n        : Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UArcInventoryComponent_Active&gt;(InventoryComponentName))\n    {\n        InventoryComponent = CreateDefaultSubobject&lt;UArcInventoryComponent&gt;(InventoryComponentName); \n\n    }\n</code></pre></p> <p>Note</p> <p>This setup, with the <code>static FName InventoryComponentName</code> and <code>SetDefaultSubobjectClass</code> allows you to have a bit of a heirarchy for your character classes.  For example, you can have a base class that uses a basic inventory component and a 'PlayerCharacter' subclass that has an Active inventory component.  It is up to you if you want to go this route.</p> <p>Next, create a new Blueprint Class that is a child of <code>AYourCharacter</code>, named BP_YourCharacter.  Verify that you have an Inventory Component on your character.</p>"},{"location":"arcinventory/1.0/tutorials/simplefps/#part-2-creating-item-slots","title":"Part 2: Creating Item Slots","text":"<p>Arc Inventory makes a very clear distinction between underlying data and the visual representation of that data.  This allows for seperation of work for larger teams, but also for quick iteration of doing temp UI to get design down.  </p> <p>We'll start with adding item slots.  Our goal will be to create an inventory layout similar to the screenshot on the marketplace for Arc Inventory.  For that, we have the following:</p> <ul> <li>Primary Weapon</li> <li>Secondary Weapon</li> <li>Head Armor</li> <li>Body Armor</li> <li>Passive Slot 1</li> <li>Passive Slot 2</li> <li>N Bag slots</li> </ul> <p>The Primary Weapon and Secondary Weapon slots can hold Active Items (IE: weapons that can be held in the character's hand), and for the sake of this tutorial, we'll say that only Pistols can go in the Secondary Weapon slot and any active items can go into primary.  Head and Body armor require items that fit directly in that slot, but Passives can hold any passive item except Head and Body armor.  N Bag Slots means that you have any number (lets say 12) slots that can hold any item, but if the item is in that bag slot it does nothing. </p> <p>Open BP_YourCharacter and navigate to the Inventory Component on it.  There, you will see 'Bag Slot Count'.  Set that to 12 (Note, you can bind it to a GameplayAttribute, and the bag will resize as that attribute changes).  This gives us N Bag Slots.</p> <p>From there, in the Inventory Layout section, Create 6 array elements.  These will be our custom slots.</p> <p>In slot 0, we want to have a primary weapon.  So, in the Tags, Give the slot the Active item tag and the Equipment tag (Ensure you set these in the Arc Inventory settings in the project settings).  This will denote this slot as both an Active and Equipment slot, and those behaviors will activate when an item is placed into this slot.  We also want to indicate that this is the 'Primary Weapon' slot, so create a new tag <code>Inventory.Slot.PrimaryWeapon</code> and give it to this slot.  </p> <p>In this slot's filter, we want to create Filter Query that accepts <code>ANY(Inventory.ItemType.Weapon)</code>, and check 'Force Single Stack'.  This will cause the Inventory to check if any item attempting to be placed into this slot contains the <code>Inventory.ItemType.Weapon</code> tag, and it will only accept items with 1 stack.  We'll set the items up later.  </p> <p>Secondary Weapon is similar to Primary weapon.  Give it the Active and Equiment tags, and create a tag named <code>Inventory.Slot.SecondaryWeapon</code> and grant it.  In the filter, create a query that checks for the <code>Inventory.ItemType.Weapon.Pistol</code> tag to ensure that only pistols can be placed in this slot.  </p> <p>For Head and Body Armor, we want to set the Tags to be have the Equipment Tag, and a tag for it's name (ie <code>Inventory.Slot.HeadArmor</code>).  In the Filter, Ensure that the query is looking for <code>ANY(Inventory.ItemType.Passive.Head)</code> and Body respectively.  We also want to force single stack.</p> <p>The passive slots are similar, however they do not need unique tags to identify them.  Give them the Equipment Tag, and give them both the <code>Inventory.Slot.Passive</code> tag, and ensure that their filters only allow passive items (perhaps <code>ANY(Inventory.ItemType.Passive) AND NOT(Inventory.ItemType.Passive.Head OR Inventory.ItemType.Passive.Body)</code>)  Slots do not need unique tags, and since any valid item can be placed in either slot.  If we wish to find specific items later in code, we can query for different information.  </p> <p>With this, the data is set up for this inventory layout.  Now lets create a few items to put into these slots</p>"},{"location":"arcinventory/1.0/tutorials/simplefps/#part-3-create-the-items","title":"Part 3: Create the items","text":"<p>Since we already created the slots, we have an idea what kinds of items could possibly exist.  From here, lets create some weapons.  </p>"},{"location":"arcinventory/1.0/tutorials/simplefps/#weapons","title":"Weapons","text":"<p>Create a new Blueprint Class that inherits from UArcItemDefinition_Active.  Active Item Definitions are item definitions that denote items that can be held in a player's hand.  Active Items can be placed into any slot, but they only can become active if placed in a slot with the Active Item tag, and the player makes that item active (usually through swapping to that item).</p> <p>In the Owned Tags variable, set the containter to have <code>Inventory.ItemType.Weapon.Rifle</code>, and any other tags you wish to describe this weapon.  I have seen setups with 10+ tags to describe each weapon, and there is very little cost to having many tags on a weapon.</p> <p>In Active Item Ability Info, Set up the Active Ability Entry, by giving it a shoot ability and bind it to input.  See GAS Documentation for methods for doing input.  Add any Attribute Sets you want to this item as well, and any tags that are granted to the player.  Anything defined and set up in Active Item Ability Info is only applied to the character when the item is held in the character's hand.  </p> <p>Once you are happy with this item, Duplicate this item and change it's Owned Tag to have <code>Inventory.ItemType.Weapon.Pistol</code>.  This will go in the secondary slot.  </p>"},{"location":"arcinventory/1.0/tutorials/simplefps/#equipment","title":"Equipment","text":"<p>Similar to weapons we want to create some new blueprint classes here.  Unlike weapons, we want to create these based on UArcItemDefinition_Equipment.  While Active items inherit from Equipment (and have many of the same properties), by inheriting from Equipment you cannot make these items active if they are in an active item slot, and thus cannot be held in hand.  </p> <p>In our Owned Tags, we want to give our equipment some tags to describe the item.  we created a few tags when we created the item slots, so make sure you use those tags to describe head and body armor.</p> <p>In the Equipped Item Ability Info, give these Head and Body armor pieces an 'Added Gameplay Effects' entry and give them a gameplay effect that is applied to the character when these items are placed into a slot with the Equipment tag.  This is done automatically.  </p>"},{"location":"arcinventory/1.0/tutorials/simplefps/#part-4-ui","title":"Part 4: UI","text":"<p>This will be very light, as UI is a very complex topic and this is a getting started tutorial.  </p> <p>Create a new blueprint widget for your inventory.  Split the widget in half using a Vertical Box, with the top half being a Canvas Panel and the bottom half a <code>BP_InventoryBagWidget</code> (Note: this is in the ArcInventory plugin.  You should duplicate it into your project if you wish to edit it)</p> <p>In the top half, place a number of BP_ItemSlotWidgets into the Canvas Panel equal to the number of unique item slots you have.  In the details panel for each of those ItemSlotWidgets, you will see an 'Item Slot Query' property.  In the Slot Type Query field, fill out th Gameplay Tag Query to query the specific slot for each widget (for example, for one of your slots you may want to query <code>ANY(Inventory.Slot.PrimaryWeapon)</code> to make that ItemSlotWidget show what is in the primary weapon slot).</p> <p>From there, consult the Example Project for how to set up responding to Drag and Drop (it's automatically set up with BP_ItemSlotWidget) and how to represent your item in the UI (also, automatically set up).  </p>"},{"location":"arcinventory/changelogs/1.2.0/","title":"1.2.0","text":""},{"location":"arcinventory/changelogs/1.2.0/#the-one-that-shipped-on-the-marketplace","title":"The one that shipped on the Marketplace","text":"<ul> <li> <p>Removed the dependency on Arc Core.  This has some far reaching effects on the plugin</p> </li> <li> <p>Active Item's Active Ability struct no longer uses a Tag &lt;-&gt; Ability map.  Instead it's now a flat array with a UArcInvInputBinder instanced object</p> <ul> <li>Arc Inventory contains a simple input binder for use.  It just takes an int32 and returns it.</li> <li>Arc Inventory Extras contains a TagMap input binder, but depends on ArcCore.  This restores the previous functionality</li> <li>You can implement your own input binder.  Simply store some kind of information regarding how to return a int32 input binding to adding and return it in the implementable function GetInputBinding.  The ASC and Ability being granted are passed into the function.  This can be implemented in blueprint as well.</li> </ul> </li> <li> <p>Deprecated the Held Item Interface.  Attaching weapons to hands, if your game needs it, can be done in the OnItemActive and OnItemInactive events in the Active Inventory Component.  These events are called on the client and the server, and are called in a predictive context.  </p> </li> <li> <p>Removed the ArcInteractable Interface due to removing ArcCore dependency.  Games need to implement how to interact with World Items now.  An example pickup ability is provided in Arc Inventory Extras</p> </li> <li> <p>Predicted Active Item Swaping.  Using the <code>SwapActiveItem</code> function, you can now swap items instantly and predictively, such as with an ability.  The Example project has an example of how to predictively swap weapons.</p> </li> <li> <p>Bugfix: Fixed a timing issue at game startup where the Active Item was incorrect</p> </li> <li>Improvement: Exposed the Active Item Slot's slot index to blueprint</li> <li>Bugfix: added ARCINVENTORY_API to two IsValid functions</li> <li>Change: The source object for abilities added to the player is the item that granted them. </li> <li>Bugfix: IWYU Fixes</li> </ul>"},{"location":"arcinventory/changelogs/1.2.1.106/","title":"1.2.1.106","text":""},{"location":"arcinventory/changelogs/1.2.1.106/#the-one-that-properly-checks-slots","title":"The one that properly checks slots","text":"<ul> <li>Fix Swapping items not working when a slot has an item</li> <li>Created a AcceptsItem_AssumeEmptySlot function to test if the slot can hold an item, assuming the slot is empty.  AcceptsItem retains it's previous behavior of failing due to a full slot.  </li> </ul>"},{"location":"arcinventory/changelogs/1.2.2.113/","title":"1.2.2.113","text":""},{"location":"arcinventory/changelogs/1.2.2.113/#the-one-that-updates-to-426","title":"The one that updates to 4.26","text":"<ul> <li>Updated to 4.26</li> <li>Improvement: Only swap item stack's owner if the owner is different than the inventory it's in.</li> </ul>"},{"location":"arcinventory/changelogs/1.2.3.115/","title":"1.2.3.115","text":""},{"location":"arcinventory/changelogs/1.2.3.115/#the-one-that-allows-for-item-transfer-between-inventories","title":"The one that allows for item transfer between inventories","text":"<ul> <li>Added a blueprint bindable event for when items are Equipped and Unequipped in the Equippable Inventory</li> <li>Improved SwapItemSlots<ul> <li>Now accepts ItemSlots from other inventories</li> <li>Will swap the items in another inventory with an item in our inventory</li> <li>Will fail if both FromSlot and ToSlot aren't the in the inventory </li> <li>Will still fail if the filters disallow the item in either slot</li> </ul> </li> </ul>"},{"location":"arcinventory/changelogs/1.2.4.118/","title":"1.2.4.118","text":""},{"location":"arcinventory/changelogs/1.2.4.118/#the-one-that-makes-items-inactive-when-removed-from-the-slot","title":"The one that makes items inactive when removed from the slot","text":"<ul> <li>Fixed a bug where items are not properly set inactive when removed from an active item slot</li> <li>fixed an issue where an active item slot is not made inactive on the client if the item is removed from the slot right before being updated. </li> </ul>"},{"location":"arcinventory/changelogs/1.2.5.123/","title":"1.2.5.123","text":""},{"location":"arcinventory/changelogs/1.2.5.123/#the-one-that-changes-attribute-initialization","title":"The one that changes attribute initialization","text":"<ul> <li>Added a callback when attribute sets are created so consumers can set attribute data</li> <li>New method of initalizing attribute sets.<ul> <li>Attribute sets are no longer stored as instanced objects in the default object.  Instead they are stored as subclasses.  A Map is provided in each ability info to select which attributes you wish to override when initalizing those attribute sets, and the value is set.  This supports both float and FAttributeData backed attributes. <li>Setting an Attribute to override sets it's base value</li> <li>Added a tool to convert the old attribute init system to the new one</li> <li>Deprecated 'Attribute Sets'.  This will set the 'Attribute Sets' property in the AbilityInfo struct to read-only.  You'll still be able to view your data, but it will be unused.  </li> <li>Removed the depricated and read only <code>FGameplayTag, TSubclassOf&lt;UGameplayAbility&gt;</code> ActiveAbilities map.</li>"},{"location":"arcinventory/changelogs/1.2.6.129/","title":"1.2.6.129","text":""},{"location":"arcinventory/changelogs/1.2.6.129/#the-one-that-fixes-some-caching-issues","title":"The one that fixes some caching issues","text":"<ul> <li>Fixed an issue where creating and removing dynamic item slots would reuse a slotid, causing slot reference collisions</li> <li>Fixed a few cases where modifying an item stack would not mark the slot array dirty, causing it to not send updates to the client.  </li> <li>Removed COND_OwnerOnly from ItemName for items.  Now everyone can see the name of the item</li> <li>Fixed a bug where Bag Inventory Widget would always look for the owning parent's inventory.  It now allows setting the target inventory for view</li> <li>Fixed an issue where Item Slot Widgets would cache the parent inventory and that cache could not be cleared.  You can now refresh Item Slot Widgets and they will find the inventory again.  </li> </ul>"},{"location":"arcinventory/changelogs/1.2.7.131/","title":"1.2.7.131","text":""},{"location":"arcinventory/changelogs/1.2.7.131/#the-one-that-stops-loops-from-going-infinite","title":"The one that stops loops from going infinite","text":"<ul> <li>Added a OnRep functions for all replicated properties to UArcItemStack.  They can be overriden by child classes</li> <li>Fixed a case where GetPreviousValidActiveItemSlot and GetNextValidActiveItemSlot could get stuck in an infinite loop if you tried to find the next valid item slot when you didn't have an item active.  </li> </ul>"},{"location":"arcinventory/changelogs/1.2.8.132/","title":"1.2.8.132","text":""},{"location":"arcinventory/changelogs/1.2.8.132/#the-one-that-fixes-cross-inventory-item-swapping","title":"The one that fixes cross inventory item swapping","text":"<ul> <li>Removed Initial Only repication from ArcItemStack's ItemDefinition Property</li> <li>Reworked cross-inventory item swapping, so it functions properly now</li> </ul> <p>Arc Inventory Example Updates</p> <ul> <li>Fixed the item tag usage so the drop item ability works by default</li> <li>Fixed the binding of the chest UI to the owning inventory, so it properly displays now</li> <li>Fixed the binding of the active item slots to the owning pawn in local hosted environments, so they should display the items properly now (single player and listen server host)</li> </ul>"},{"location":"arcinventory/changelogs/1.2.9.134/","title":"1.2.9.134","text":""},{"location":"arcinventory/changelogs/1.2.9.134/#the-one-that-fixes-replication-for-map-placed-objects","title":"The one that fixes replication for map-placed objects","text":"<ul> <li>Removed \"Is Name Stable for Networking\" in ArcItemStack.  ArcItemStacks are never name stable.  A dynamic netguid should always be created for them</li> <li>Properly replicate sub-items for sub-items.  </li> </ul>"},{"location":"arcinventory/changelogs/1.3.0.138/","title":"1.3.0.138","text":""},{"location":"arcinventory/changelogs/1.3.0.138/#the-one-that-replicates-subitemstacks-better","title":"The one that replicates subitemstacks better","text":"<ul> <li>Fixed the ArcInventoryComponent's <code>OnItemSlotChange</code> event on the client.  It should now mirror the same parameters as the server's version.</li> <li>Reworked Subitem replication.  Due to an issue with Unreal Engine replication during the initial replication frame, UArcItemStack's SubItem array was being updated before the subitems were being created.  This would lead to the array having null entries when an item is replicated to the client, but only for a frame.  The next frame, the NetDriver would fixup the pointers and it would be valid.  </li> </ul> <p>To Fix this, UArcItemStack's SubItem array has been changed to a FFastArraySerializer struct.  This necissitated an API change, thus the version increment.  Now, there is an event when a SubItem is added or removed from the SubItemStacks array, and binding to that event will catch when the netdriver fixes up the sub item stack pointers.  You will still get null sub item stacks in the array if you try to access the array on the initial replication frame of a new item.</p> <ul> <li>Changed UArcItemStack's GetSubItemStacks blueprint node from a getter to a blueprint pure function that returns an array.</li> <li>Modified BP_SimpleLargeItemCard to account for the SubItemStack changes</li> </ul>"},{"location":"arcinventory/changelogs/1.3.1.144/","title":"1.3.1.144","text":""},{"location":"arcinventory/changelogs/1.3.1.144/#the-one-that-better-supports-ue5","title":"The one that better supports UE5","text":"<ul> <li>Fixed a number of deprecations in UE5</li> <li>Removed the Force Replication code.  It didn't quite work, and was causing issues</li> <li>Fixed an include error in certain build configurations</li> </ul>"},{"location":"arcinventory/changelogs/1.3.2.145/","title":"1.3.2.145","text":""},{"location":"arcinventory/changelogs/1.3.2.145/#the-one-that-fixes-a-cross-inventory-regression","title":"The one that fixes a cross-inventory regression","text":"<ul> <li>Fixed a regression in Cross-Inventory item swapping that the UE5 support work introduced.  </li> </ul>"},{"location":"arcinventory/changelogs/1.3.3.150/","title":"1.3.3.150","text":""},{"location":"arcinventory/changelogs/1.3.3.150/#the-one-that-stacks-items-and-fixes-bugs","title":"The one that stacks items and fixes bugs","text":"<ul> <li>Blueprint Rework: Updated the Swap Item Stack ability to be aware of mergeable item stacks.  It will now attempt to merge item stacks that can be merged, rather than just swapping their positions</li> <li> <p>Blueprint Rework: Updated the Item Slot Widgets to show the item's stack size if it has one.  </p> </li> <li> <p>Fixed Equipped Ability Info not being set on Active Item Slots</p> </li> <li> <p>Added a NetSerializer to the ItemSlotFilter so it is properly replicated to clients</p> </li> <li> <p>Merge Item Stacks no longer cuts off some stacks if otherstack size is too large</p> </li> <li>Stack size is now replicated to everyone</li> <li>Invalid static slot variables are now implemented in .cpp, fixing linker errors</li> <li>Item Def's DefaultItemStackClass was unused.  It's not chosen instead of the Item Generator's class depending on which item class is more specialized (Generator's is chosen if it's more specialized and vice versa)</li> </ul>"},{"location":"arcinventory/changelogs/1.4.0.157/","title":"1.4.0.157","text":""},{"location":"arcinventory/changelogs/1.4.0.157/#the-one-that-updates-to-427","title":"The one that updates to 4.27","text":"<ul> <li> <p>Fixed a bug where abilities weren't being applied if they shared the same class as an ability on another item, and you were switching items that frame.  We now check if the ability is Pending Remove when the same class ability exists, and add our new ability anyway if the old ability is pending remove</p> </li> <li> <p>Updated tags to use NativeGameplayTags </p> <ul> <li>Defined Tags:    <ul> <li><code>Inventory.Slot.Bag</code> </li> <li><code>Inventory.Slot.Equipped</code> </li> <li><code>Inventory.Slot.Active</code> </li> <li><code>Ability.Inventory.DropItem</code> </li> <li><code>Ability.Inventory.SwapItems</code> </li> <li><code>Ability.Inventory.SwapPending</code></li> </ul> </li> </ul> </li> </ul> <p>These Tags are now defined automatically by the plugin, and will show up in all places gameplay tags are found.  You no longer need to define them yourself.</p> <p>Note</p> <pre><code>If you have your own custom tags set up in the Arc Inventory Developer Settings, you'll need to update your tags to match these.\n</code></pre> <ul> <li>Removed Deprecated AbilityTagMappings from the arc inventory gameplay tag settings </li> <li>Removed Deprecated Attribute set field from item def ability info, and removed the tools to convert from this to the new ability mapping  </li> <li>Removed Deprecated HeldItemInterface</li> <li>Removed Unusued ArcInventoryLocalPlayerSubsystem</li> </ul>"},{"location":"arcinventory/changelogs/1.4.1.163/","title":"1.4.1.163","text":""},{"location":"arcinventory/changelogs/1.4.1.163/#the-one-that-cleans-up-some-c-linking-issues","title":"The one that cleans up some c++ linking issues","text":"<ul> <li>New: LootItem and PlaceItemIntoSlot now attempt to stack items into other items that allow stacking.  Both may return false now if the item was partially added to the inventory.</li> <li>New: SwapItemSlots now accepts empty item slots as valid swap targets</li> <li>Fix: Added ARCINVENTORY_API to a number of constants and the native tags</li> <li>Fix: Fixed a linux linker error in unity builds caused by reusing a same name.  This only occours on clang.</li> </ul>"},{"location":"arcinventory/changelogs/1.4.2.174/","title":"1.4.2.174","text":""},{"location":"arcinventory/changelogs/1.4.2.174/#the-one-for-unreal-50","title":"The one for Unreal 5.0","text":"<ul> <li> <p>Updated to Unreal 5.0!</p> </li> <li> <p>Fixed an ensure that could hit when the plugin was re-registered with an actor</p> </li> <li>Added support for unbinding from an AbilitySystemComponent, used in situations where the ASC is on the Player State and the pawn is changed.  <ul> <li>This will remove all of the abilities, effects, and tags from any item from the ASC.  It does not destroy everything though, so they can be placed right back on an ASC when the owning actor regains it's ASC.</li> <li>This does not happen automatically.  You must call BindToASC() and UnbindFromASC() when you remove an ASC from the owning actor.  </li> </ul> </li> <li>Added support for adding the same ability multiple times to an ASC</li> <li>Added a utility function to copy an inventory from one Inventory Component to another.  </li> <li>Fixed a crash when trying to get an inventory comp from a null actor (now just returns null)</li> <li>Fixed a crash when a stored attribute set goes null for whatever reason</li> <li>Fixed attribute sets being owned to the owner of the inventory and not the owner of the owner's ASC</li> </ul>"},{"location":"arcinventory/changelogs/2.0.0.263/","title":"Arc Inventory 2.0","text":"<p>Welcome to Arc Inventory 2.0!  </p> <p>Arc Inventory 2.0 is a massive rework of inventory data layout, moving Item Definitions from a inheritance based model to a more data oriented design.  Arc Inventory is faster, more flexible, easier to extend than ever before.  </p> <p>The primary feature of Arc Inventory 2.0 is the introduction of the Modular Inventory Component, replacing the old inheritance model.  The 1.0 inventory subclasses have become Inventory Processors, which are component-like objects that exist on the Modular Inventory.  The 1.0 item definition subclasses have been broken up into Item Fragments, or item subobjects that hold units of data, and can be placed on either an Item Definition or an Item Stack.</p> <p>Tip</p> <p>Check out the Arc Inventory 1.0 to 2.0 Migration Guide!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#modular-inventory-item-processors","title":"Modular Inventory &amp; Item Processors","text":"<p>The hierarchy of Inventory Components in 1.0 has been removed and entirely replaced by the Modular Inventory Component, featuring a number of improvements.</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#improved-inventory-events","title":"Improved Inventory Events","text":"<p>Arc Inventory 1.0 had a number of events to bind to depending on the class of the Inventory Component.  The Modular Inventory now has a single event that can be listened to, providing a centralized handling of reactable inventory events and better replication of events.</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#improved-dynamic-attribute-set-handling","title":"Improved Dynamic Attribute Set Handling","text":"<p>Dynamic Attribute Sets in 1.0 were a bit buggy and dangerous to use.  Arc Inventory 2.0 fixes a number of issues around them, including clearing Attribute Modifier Aggregators when attribute sets are removed and ensuring no Gameplay Effects apply to any attribute that is being removed.  You can now safely use dynamic attribute sets!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#improved-networking","title":"Improved Networking","text":"<p>The Modular Inventory improves networking performance, making better use of FFastArraySerializer, reducing replication events, and improved subobject handling.</p> <p>NOTE: Push Model networking is in progress and still unsupported as of the 2.0 release.  Expect it shortly!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#inventory-processors","title":"Inventory Processors","text":"<p>The hierarchy of inherited Inventory components has been removed, and the functionality of each inventory component has been replaced with the new Inventory Processors.  Processors are stateful, replicated subobjects that handle gameplay functionality for the inventory.  Processors can create or remove Inventory Slots, Take actions when items are added or removed to slots, and much, much more.  Processors can be created in C++ or Blueprint, have a number of overridable events, and can be deeply customized for your game's inventory needs.  </p> <p>Arc Inventory 2.0 ships with all the functionality of the 1.0 inventories as processors: </p>"},{"location":"arcinventory/changelogs/2.0.0.263/#bag-processor","title":"Bag Processor","text":"<p>The Bag Processor creates a list of item slots on the modular inventory, and manages those slot's tags and filters.  Similar to the 1.0 Bag Inventory, 2.0 supports multiple bags on one inventory, and dynamically resizable bags!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#equipment-processor","title":"Equipment Processor","text":"<p>The Equipment Processor watches a set of item slots on the inventory, and applies Gameplay Abilities, Gameplay Effects, and Attribute Sets to the owning actor when items are placed into those slots, or removed when items are removed.  </p>"},{"location":"arcinventory/changelogs/2.0.0.263/#active-processor","title":"Active Processor","text":"<p>The Active Processor manages a list of potentially active items, and manages placing Gameplay Abilities, Gameplay Effects, and Attribute Sets onto the owning actor when an item is made active.  </p>"},{"location":"arcinventory/changelogs/2.0.0.263/#modular-item-stack-item-stack-fragments","title":"Modular Item Stack &amp; Item Stack Fragments","text":"<p>One of the key features of Arc Inventory 2.0, Modular Item Fragments allow for users to store a wide array of data types on item stacks.  In 2.0, the hierarchy of Item Definitions and Item Stack classes have been removed and replaced with the Modular Item Stack.  </p> <p>Item Data has been migrated to new Item Stack Fragments, which can be stored on either the Item Stack or in new Modular Item Definitions.  Instead of getting the item definition from an item stack and casting it to the proper type, you now simply query for an Item Fragment.</p> <p>Modular Items now support fully dynamic item data.  While this is not recommended in Multiplayer due to the replication cost, you can create custom items entirely from dynamically spawned fragments on an item stack, no Item Definition needed!</p> <p>Sub Items on an Item Stack can now override data on a parent item stack.  Simply include an instance of the same type and tags as a parent item's fragment, and the child's version will be returned in a query instead of the parent's version!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#new-item-definitions","title":"New Item Definitions","text":"<p>Modular Item Stacks make use of a new form of Item Definition, the Modular Item Definition.  Modular Item Definitions are Data-Asset derived objects that hold a list of Fragments.  Users no longer need to look up the Item Definition to retrieve data from it, as Fragment Queries will access it if it exists.  </p>"},{"location":"arcinventory/changelogs/2.0.0.263/#dynamic-fragments","title":"Dynamic Fragments","text":"<p>While the primary method of giving an Item Stack fragments is to use an Item Definition, Modular Item Stacks support adding fragments to an item in a dynamic fashion.  Dynamic Fragments are fully replicated and can represent dynamic data on an Item Stack.  Dynamic Fragments can override fragments added by an Item Definition, allowing for the creation of custom properties on items.</p> <p>Additionally, while not recommended in multiplayer, an item can be created entirely out of dynamic fragments!  No Item Definition needed!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#fragment-queries","title":"Fragment Queries","text":"<p>Item Data is now retrieved via Item Fragment Queries.  The Item Stack exposes a number of query methods to retrieve item fragments from a given item stack.  Fragment Queries are available in both C++ and Blueprint!</p> <p>The FindFirstFragment query will return the first fragment it can find from either the Children Items, Dynamic Fragments, or Item Definition in that order!  You can use this to override item properties either using dynamic fragments or child items like Perks, Attachments, or Randomized Properties.</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#item-stat-tags","title":"Item Stat Tags","text":"<p>Similar to Lyra, Modular Item Stacks now support \"Item Stat Tags\", or a mapping of Tag=&gt;Int32.  These Stat Tags can be used for various properties like Stack Size, Durability, or whatever you need.  They are supported in multiplayer and notified using the Modular Inventory's new event system!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#fragments","title":"Fragments","text":"<p>Arc Inventory 2.0 ships with a number of built in fragments, but you can create your own in Blueprint or C++ if you need more for your items.</p> <p>Built in fragments include:  * Skeletal Mesh Fragment * Static Mesh Fragment * Text Fragment * Texture Fragment * Item Card Fragment * Ability Fragment * Rarity Fragment * Stackability Fragment</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#assorted-changenotes","title":"Assorted Changenotes:","text":"<ul> <li>Added a new UArcItemStackBase base class, used to share functionality between 1.0 UArcItemStack and 2.0 UArcItemStackModular.  Almost every base-class Inventory Component function returns and uses UArcItemStackBase </li> <li>Added Mutable and Immutable accessors for Item Slots, reducing the need to replicate item slots as often.  If you do not need to modify any of the properties of an ItemSlot, accessing it via the const GetItemSlot() function will no longer trigger a replication of the slot.  </li> <li>Improved removing dynamic attribute sets, fixing crashes related to removing attributes that a gameplay effect is referencing.</li> <li>All tags used internally by ArcInventory are now native tags.  You no longer need to add any tags to your project to use ArcInventory.</li> <li>Improved Active Item Replication in extremely poor network conditions, fixing issues such as 'switch to pending item slot' arriving long after BeginPlay in poor network conditions leading to clients having an invalid active item.</li> <li>Properly send notifications when an item is looted but stacks with an item already in the inventory.  </li> <li>Fixed incorrect inventory events firing after a drag and drop action</li> <li>Improved <code>ShowDebug Inventory</code>, displaying more useful information and following the HUD's debug target (allowing the debugging of other inventories, not just the currently controlled pawn's)</li> <li>Fixed a number of compile errors when Unity builds are off.</li> <li>Added an EventTag property to LootItem, allowing users to pass information as to why an item was looted.  </li> </ul>"},{"location":"arcinventory/changelogs/2.0.0.263/#arc-inventory-example","title":"Arc Inventory Example","text":"<p>The Inventory Example has been rewritten for Arc Inventory 2.0, and now runs on Unreal Engine 5.0!  </p> <p>You can get it here: https://drive.google.com/file/d/1p3AgfIiSpDTTwt0kQ_2z4odG4h_QSYuN/view?usp=share_link</p> <ul> <li>Reworked folder structure to be easier to find example content</li> <li>Added support for Enhanced Input across the whole example.</li> <li>Provided an Enhanced Input extension for Arc Inventory so that active abilities can be bound to Enhanced Input actions.  </li> </ul> <p>Note</p> <p>The Chest and Inventory Manipulation tutorials are not implemented in the new example.  Expect them soon!</p>"},{"location":"arcinventory/changelogs/2.0.0.263/#special-thanks","title":"Special Thanks:","text":"<p>A huge thank you to Puny Human engineers Mike Z, Steeve, Voltaire, Daniel, and Trikeri for various bug fixes and feature implementations.  </p>"},{"location":"arcinventory/changelogs/2.0.1.270/","title":"2.0.1.270","text":""},{"location":"arcinventory/changelogs/2.0.1.270/#the-one-for-51","title":"The one for 5.1","text":"<p>This release is for Unreal 5.0 and Unreal 5.1</p> <ul> <li>Added 5.1 support</li> <li>Added experimental support for 5.1's Replicated Subobject List</li> <li>Added <code>AddReplicatedSubobjects</code> and <code>RemoveReplicatedSubobjects</code> to ArcItemStackBase.  If you add or remove custom subobjects, override these functions to do stuff to them when they are added for replication.</li> <li>Fixed include orders to work with the 5.1 include order changes (this applies to 5.0, but has no effect)</li> <li>Added mutable and immutable foreach subitem stack functions to ItemStackBase in the same vein as the foreach fragment functions in item stack modular</li> </ul>"},{"location":"arcinventory/changelogs/2.0.2.271/","title":"2.0.2.271","text":""},{"location":"arcinventory/changelogs/2.0.2.271/#the-one-that-initializes-structs","title":"The one that initializes structs","text":"<p>This release is for Unreal 5.0 and Unreal 5.1</p> <ul> <li>Fixed a build warning or sometimes error regarding uninitialized properties in structs</li> </ul>"},{"location":"arcinventory/changelogs/2.1.0.284/","title":"2.1.0.284","text":""},{"location":"arcinventory/changelogs/2.1.0.284/#the-one-that-allows-item-processors-to-work-with-items-being-placed-into-the-inventory","title":"The one that allows Item Processors to work with items being placed into the inventory","text":"<p>This release is for Unreal 5.0 and Unreal 5.1</p> <ul> <li>Breaking Change - Stacking behavior is disabled by default.  You will need an ArcInventoryProcessor_Stacking on your inventory component to enable default stacking behavior. </li> <li>Breaking Change - <code>UArcItemStackModular</code> instance functions <code>CanStackWith</code> and <code>MergeItemStacks</code> have been deleted and moved to <code>UArcItemFragment_Stackable::CanStackWith()</code> and <code>UArcItemFragment_Stackable::MergeItemStacks</code></li> <li> <p>Breaking Change - * the Signature for UArcInventoryComponent <code>AcceptsItem</code> and <code>AcceptsItem_AssumeEmptySlot</code> is now <code>bool AcceptsItem(UArcItemStackBase* Item, const FArcInventoryItemSlotReference&amp; ToSlot, FArcInventoryItemSlotReference FromSlot)</code> and  <code>bool AcceptsItem_AssumeEmptySlot(UArcItemStackBase* Item, const FArcInventoryItemSlotReference&amp; Slot, FArcInventoryItemSlotReference FromSlot);</code> (Added the third parameter)</p> </li> <li> <p>Major Change - Inventory Processors can now control how items are placed into inventories!</p> </li> <li>Added <code>EArcItemSlotAcceptance SlotAcceptsItem(UArcItemStackModular* ItemStack, const FArcInventoryItemSlotReference&amp; Slot, FArcInventoryItemSlotReference FromSlot)</code> to the Inventory Processor (and blueprint override) to determine if an item can be placed into an item slot.  FromSlot will be invalid if coming from the world</li> <li> <p>Added <code>EArcSourceItemState ProcessItemSlotSwap(UArcItemStackModular* SourceItem, FArcInventoryItemSlotReference FromSlot, UArcItemStackModular* DestItem, FArcInventoryItemSlotReference ToSlot)</code> to Inventory Processor to allow the processor to change the SourceItem.  From Slot will be invalid if the item is coming from nowhere (like being looted).  This allows processors to change the behavior of SourceItem, such as stacking it into DestItem if possible.  </p> </li> <li> <p>Major Change - Inventory Processors can now weight item slots for Loot Item</p> </li> <li>LootItem() now gets a list of all valid slots that an item can go into, sorts them by their weighted value, and tries to put the item into them in sequence.  </li> <li> <p>Processors can override <code>int ItemSlotWeightForItem(UArcItemStackModular* ItemStack, const FArcInventoryItemSlotReference&amp; Slot, FGameplayTag LootTag)</code> to return a weight value that is added to the total weight for that item slot.  Loot Tag is passed in by LootItem</p> </li> <li> <p>Fixed a bug where swapping items between inventories wasn't working</p> </li> <li>Fixed a bug where the Resizing Bag wasn't working</li> <li>Fixed ArcInventoryComponent_Modular not blueprint spawnable</li> <li>Fixed a bug where swapping items between two slots would not re-add abilities.  </li> <li>Fixed a bug where the Ability Active event would fire multiple times</li> <li>ArcItemStackWorldObject now uses experimental subobject replication lists</li> <li>Fixed various instances of the engine complaining about properties not initialized properly</li> </ul>"},{"location":"arcinventory/changelogs/2.1.1.293/","title":"2.1.1.293","text":""},{"location":"arcinventory/changelogs/2.1.1.293/#the-one-that-cleaned-up-various-bugs","title":"The one that cleaned up various bugs","text":"<p>This release is for Unreal 5.0 and Unreal 5.1</p> <ul> <li>Added a CanAttachTo implementation to Modular Item Stacks that accept other Modular Item Stacks, allowing any modular item to be added to any other modular item.  </li> <li>You can still override Modular Item Stack if you wish to change this behavior</li> <li>Fixed a crash when trying to replicate null subitems</li> <li>Fixed a bug where an item slot with Equipment and Active processors seeing it would conflict with the Ability Info struct (they'd overwrite each other)</li> <li>Fixed erroneously removing the active item immediately after adding it during an ItemSlotChange</li> <li>Removed the monolithic GameplayTags.h header plugin-wide.  This should reduce the compile warnings in 5.1 </li> <li>There are a few more monolithic headers used.  They'll be fixed in future versions.  Sorry for the compile warning </li> <li>Added const correctness for various Item Stack getters that don't mutably access an item slot</li> <li>Fixed a crash when trying to replicate a null item stack in the Item Stack World Object</li> </ul>"},{"location":"arcinventory/changelogs/2.1.2.303/","title":"2.1.2.303","text":""},{"location":"arcinventory/changelogs/2.1.2.303/#the-one-that-reworked-swapping-active-items","title":"The one that reworked swapping active items","text":"<ul> <li>Fixed a number of compile errors if you are building the plugin in Include What You Use mode</li> <li>Fixed an inverted condition in SwapItemSlots not allowing cross inventory swaps</li> <li>Added Blueprint Callability to the ActiveItemProcessor's MakeItemInactive and SwitchToPendingItem functions</li> <li>Cleaned up active item swapping, giving users more control over what the resulting active item slot index will be when swapping items <ul> <li>This adds a new default-false boolean property to SwapActiveItems to allow swapping to land on a valid item slot that does not have an item in it.  If false, swap active items will land on INDEX_NONE for the active slot if you try to swap to a slot that doesn't have an item in it.  True will allow that swap (but no item will be made active)</li> </ul> </li> <li>Moved the authority checks for the OnInventoryUpdate to the functions that actually need authority, allowing OnInventoryUpdate to be called in all network roles.  </li> </ul>"},{"location":"arcinventory/changelogs/2.2.0.306/","title":"2.2.0.306","text":""},{"location":"arcinventory/changelogs/2.2.0.306/#the-one-that-adds-context-to-item-swapping","title":"The one that adds context to item swapping","text":"<ul> <li>BREAKING CHANGE: Added a context tag to all item operations that involve changing items in slots.  This is an extension of the Loot Tag in LootItem()</li> <li>The Inventory Update delegate has had it's signature changed to include this context tag.  If you bind to that event, you will need to update your code to take the new parameter.</li> <li>Fixed an incorrect condition when swapping item slots</li> <li>Fixed a crash when trying to add fragments without an owner.</li> </ul> <p>UPCOMING BREAKING CHANGE</p> <p>In Arc Inventory 2.3.0, I will be deleting all of the Arc Inventory 1.0 classes.  Expected Date for that is around June of 2023.  Please migrate to Arc Inventory 2.0's Modular Inventory features before then!  If you are already using the Modular Inventory, you have nothing to worry about or do.  </p>"},{"location":"arcinventory/changelogs/2.2.1.311/","title":"2.2.1.311","text":""},{"location":"arcinventory/changelogs/2.2.1.311/#the-one-that-updates-to-52","title":"The one that updates to 5.2","text":"<ul> <li>Added engine support for UE5.2</li> <li>Fragment Tags are now Replicated by default</li> <li>Deprecated all blueprints inside the plugin, and migrated them over to the example project.  Please view the deprecations page for more information</li> <li>Fixed stacking two item stacks across different inventories deleting both items</li> <li> <p>Fixed incorrect stacking logic computing the wrong stack sizes and swapping them after adjusting their stack sizes</p> </li> <li> <p>BREAKING CHANGE: <code>UArcInventoryProcessor::ProcessItemSlotSwap</code> now returns a bool instead of a <code>EArcSourceItemState</code>.  <code>ProcessItemSlotSwap</code> should return true if the function has handled item swapping, false if it did not handle it.  All processors are given the opportunity now to process the swap, regardless of if another processor has modified it.  </p> </li> </ul>"},{"location":"arcinventory/changelogs/2.3.0/","title":"2.3.0","text":""},{"location":"arcinventory/changelogs/2.3.0/#the-one-that-removes-arc-inventory-10","title":"The one that removes Arc Inventory 1.0","text":""},{"location":"arcinventory/changelogs/2.3.0/#deprecation-notice","title":"DEPRECATION NOTICE","text":"<p>All deprecated items were removed in this release.  They were noted in the deprecations page.  If you were relying on any Arc Inventory 1.0 code or the example blueprints in the plugin, please consult either the Example Project or message RoyAwesome on discord for steps to resolve these issues.</p>"},{"location":"arcinventory/changelogs/2.3.0/#version-naming-scheme-change","title":"Version Naming Scheme Change","text":"<p>Starting with 2.3.0, the version scheme has changed.  The Version Scheme now matches closer to SemVer, with Major.Minor.Patch-githash.  The Githash replaces the old changelist number in the previous version.  Note: If you access Arc Inventory on the Puny Human Github, the version will always be Major.Minor.X-git, for all major/minors.  I do not update the patch or githash for git distributions.  </p>"},{"location":"arcinventory/changelogs/2.3.0/#changenotes","title":"Changenotes","text":"<ul> <li>Removed Example Blueprints.  They are now located in the Example project.  This is to assist with maintaining and tagging appropriate versions of the blueprint assets.  </li> <li>Removed Arc Inventory 1.0 classes and types.  </li> <li>Removed ArcAbilityTask_WaitItemSwitch, as it was an unfinished example that is more fleshed out in the Swap Active Item ability in the Example Project.  </li> <li>Removed DefaultItemStackClass from the Inventory Developer Settings.  ArcItemStack_Modular is the default and probably the only item stack you need</li> <li>Migrated the templated QueryMatchingAssets in the BPFL to the implementation.  It never worked outside of the module, so it's now just hidden.</li> <li>Removed GetBagInventoryComponent, GetEquippableInventoryComponent, and GetActiveInventoryComponent from the BPFL.  Replaced by GetActiveProcessor and GetEquipmentProcessor.</li> <li>Removed GetUIDataFromItemDefinition from the BPFL, as it's replaced by item fragments</li> <li> <p>Fixed GetActiveAttributeFromItemSlot and GetEquippedAttributeFromItemSlot to work with modular item stacks</p> </li> <li> <p>Reworked ItemSlotWeightForItem to return a TOptional.  There is still a blueprint override.  </p> </li> <li>Bags now sort items by default, restoring a previous behavior.  This can be disabled via checkbox.</li> <li>If no item slot has a sort priority by any processor, the item cannot be looted.</li> <li>Fixed crash when generating items if you somehow have an item definition with null fragments.  </li> <li>Fixed duplicate ability activations in certain situations when swapping item slots with active items.  </li> </ul>"},{"location":"arcinventory/changelogs/2.3.2/","title":"2.3.2","text":""},{"location":"arcinventory/changelogs/2.3.2/#the-one-that-updates-to-53","title":"The one that updates to 5.3","text":"<ul> <li> <p>Updated the plugin to Unreal Engine 5.3</p> <ul> <li>Note: Arc Inventory only supports the 3 most latest Unreal versions.  This means the 3 supported UE versions are 5.1, 5.2, and 5.3.  </li> <li>This version works in UE 5.0 but no support will be offered for it. </li> </ul> </li> <li> <p>Added \"ForceItemIntoItemSlot\" and \"ForceRemoveItemFromSlot\" protected functions in Arc Inventory Processor to take over inserting and removing items.</p> <ul> <li>These are advanced functions.  This allows you to manipulate the inventory internals directly</li> <li>They do not invoke callbacks, you must invoke callbacks if you call these functions.</li> <li>They are intended to handle things like grid processors and the like, so that you can directly control what items go where.</li> </ul> </li> <li>Added SlotAcceptsItem_AssumeEmpty to Processor to handle the assume empty slot acceptance case.  This allows you to write acceptance code for swapitemslot cases.</li> </ul>"},{"location":"arcinventory/changelogs/2.3.4/","title":"2.3.4","text":""},{"location":"arcinventory/changelogs/2.3.4/#the-one-that-fixes-many-many-bugs","title":"The one that fixes many, many bugs.","text":"<p>Arc Inventory 2.3.4 supports 5.2, 5.3, and 5.4.  </p>"},{"location":"arcinventory/changelogs/2.3.4/#core","title":"Core","text":"<ul> <li>Improved the replication of slots</li> <li>Removed the NAMED_ITEM_SLOT concept, and improved equality checks between item slots</li> <li>Re-Added the \"Default Item Stack Class\" to the Developer Settings.  This will be the Item Stack Class chosen when generating items by default.  It can be overriden in many places</li> <li>Improved Query Functions in the Item Stack Base</li> <li>Added Query modes to match Item Definitions</li> <li>Added \"Default Item Stack\" for Item Definitions to the ModularBPFL.  This lets you get an item stack that is not replicated that can be used as a default version of that itemstack, similar to a CDO.  </li> <li>Added helper methods for quickly adding items to inventory.</li> <li>Added \"Exact Item Stack\" inventory queries.  This is mostly useful for finding all slots an item is in.  </li> <li>Added the ability to specify the owner of a newly generated ItemStack in <code>UArcInventoryModularBPFL::QuickGenerateModularItem</code>, saving an object duplication if you provide the owner of the inventory the item will be placed into if the item is to be instantly placed into an inventory.</li> <li>Added the ability to get items from the inventory even if the item is pending kill</li> </ul>"},{"location":"arcinventory/changelogs/2.3.4/#inventory","title":"Inventory","text":"<ul> <li>Fixed Modular Inventory calling the incorrect processor's OnRep functions when replicating</li> <li>Fixed Processors RPCs not working</li> <li>Fixed various instances of Processors not being resolved correctly when loading (Instanced Subobject woes)</li> <li>Improved Pre-Process Item Swap, and used it in more places.  You can now take complete control over item swapping for specific items in a processor</li> <li>Added bulk item slot creation and removal, which invokes the Inventory Update event once for all the slots added in bulk</li> <li>Batched Callbacks during slot replication so that they all happen at the end of the replication frame.  Ensure we only call one of each callback.</li> <li>Added an optional context tag for RemoveAllItemsFromInventory  </li> <li>Cleaned up some issues around Item Slot Generations (NOTE: Item Slot Generations will be removed in a future version)</li> <li>Added verbose inventory logging around adding and removing items to the inventory.  </li> <li>Added a \"Contains Item Stack\" function</li> <li>Added a runtime \"AddInventoryProcessor()\" function.</li> <li>Optimized LootItem() and allowed processors to opt into being considered for looting.  This dramatically increases performance with many processors that do not score item slots for LootItem.</li> <li>Added sorting of Processors for ProcessItemSwap, so that users have better control over which processors go first when deciding how to put items into the inventory.</li> <li>Modular Inventory Events are now split based on the modular inventory event tag.  In C++ you will need to bind to the specific tag's event.  There is a static event that catches all tags.  This allows for optimization reducing the number of callbacks per tag.  Note: This is the first part of a major refactor of the event system.  </li> </ul>"},{"location":"arcinventory/changelogs/2.3.4/#active-processor","title":"Active Processor","text":"<ul> <li>Fixed the double activate Bug</li> <li>Reworked the OnActive event.  It is now called regardless of an ActiveAbilityInfo on the item, and is called more reliably on the client in network relevancy scenarios</li> <li>Added a behavior toggle for what to do if an item that is currently active is removed.</li> </ul>"},{"location":"arcinventory/changelogs/2.3.4/#equipment-processor","title":"Equipment Processor","text":"<ul> <li>Fixed some unreliability in the OnEquipped event not being fired in relevancy scenarios</li> </ul>"},{"location":"arcinventory/changelogs/2.3.4/#item-stack","title":"Item Stack","text":"<ul> <li>Added and replicated OnStatTag changed events</li> <li>Added Loose Item Tags that are replicated.  You can now custom tag items.  </li> </ul>"},{"location":"arcinventory/changelogs/2.3.4/#ui","title":"UI","text":"<ul> <li>Item Cards now have an Item Slot in addition to the item stack.  This is largely optional, but helps when implementing widgets that may have default values</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/","title":"2.4.0","text":""},{"location":"arcinventory/changelogs/2.4.0/#the-one-that-revamps-how-items-are-stored","title":"The one that revamps how items are stored","text":""},{"location":"arcinventory/changelogs/2.4.0/#major-changes","title":"Major Changes","text":""},{"location":"arcinventory/changelogs/2.4.0/#new-item-slot-container","title":"New Item Slot Container!","text":"<p>This version of Arc Inventory contains a massively improved Item Slot Container that powers both the inventory component and the item stacks.  This container is no longer an array with fixed indices, but instead a Hash Set that hashes slot ids and tags and allows for O(1) lookup from an Item Slot Reference.  This also eliminates the need for item slot generations, as now references cannot go stale.  Item Slot creation is O(1) now as well, as is deletion!  In general, creating and deleting item slots is trivial, and you can add or remove them as often as you would like.</p> <p>Sub Item Stacks on items are COMPLETELY reworked, and major breaking changes have happened there to accomodate the new Item Slot Container for them.  Sub Item Stacks now have slot references.</p>"},{"location":"arcinventory/changelogs/2.4.0/#improved-lootitem-behavior","title":"Improved LootItem() behavior","text":"<p>The LootItem() function on the Inventory Component is one of the most useful tools in the inventory.  However, controlling where the item will go in a Loot Item call has long been difficult.  The function would simply pick the first possible slot for the item.  Now, you can provide preferences to the LootItem() call and processors can use those preferences to score slots better.</p> <p>Also, LootItem has been massively optimized!  Prebviously, each processor would loop through every item slot.  Now, the Processor is provided a map of Item Slot References and Score and is expected to fill out scores for each item!</p>"},{"location":"arcinventory/changelogs/2.4.0/#proxy-item-slot-references","title":"Proxy Item Slot References","text":"<p>You can now create item slot references that do not exist, but may exist in the future!  This is extremely useful for processors that can fake having many slots, but only promote those fake slots to a real one if an item attempts to be placed into that slot.  This is useful for things like large grids of item slots, large lists, or similar processors.  </p>"},{"location":"arcinventory/changelogs/2.4.0/#improved-data-coherence-and-push-model-support","title":"Improved Data Coherence and Push Model Support","text":"<p>For various reasons, almost every public property across the plugin's classes have been made private and getters/setters have been added for them.  The Item Slot Reference mainly has been made immutable, as now it's a hashable object for the item slot cotnainer.  All replicated classes now support UE's Push Model replication, bringing about a massive performance increase when replicating the inventory system.</p>"},{"location":"arcinventory/changelogs/2.4.0/#added-inventory-presets","title":"Added Inventory Presets","text":"<p>A new data object has been added to split out the inventory setup code and help prevent blueprint data corruption issues.  Inventory Presets allow you to set an inventory's default slots and processors, and you can share them across multiple classes.  They also support some inheritance!</p> <p>They also really help when working with source control locks</p>"},{"location":"arcinventory/changelogs/2.4.0/#improved-logging-and-data-validation","title":"Improved logging and data validation","text":"<p>Across the plugin, Data Validation has been added to prevent incorrect data setups.  These validators will now throw errors, prevent objects from being saved so long as the error exists, and fail your builds if there is an error. This has additionally allowed the removal of some safety checks, improving performance, as things like nulls can no longer slip in to certain lists in item definitions and the like.</p> <p>Additionally, LogInventory now logs all inventory actions if you enable verbose logging.  Try <code>log LogInventory verbose</code> sometime!</p>"},{"location":"arcinventory/changelogs/2.4.0/#all-patch-notes","title":"All Patch notes:","text":""},{"location":"arcinventory/changelogs/2.4.0/#general","title":"General","text":"<ul> <li>Breaking - Across the plugin, all replicated properties have been made private, and functions to get those properties were added.  This is to support Push Model replication.  </li> <li>Added far more robust logging when LogInventory is set to verbose.  This should give you a really good idea what is happening in the inventory when you enable verbose logging.  </li> <li>Active Item Swapping is now entirely predicted!  You can just call the swap active item calls on the client and server at the same time, and the active processor will resolve mispredictions.</li> <li>Equipment Processor now fires it's On Equipped events regardless of whether or not there is an AbilityInfo on the item.</li> <li>Added <code>ArcInventory.Debug.PrintInventory</code> console command which prints out the same debug information as the ShowDebug Inventory command.  Useful for copy+pasting!</li> <li>Forced support for 5.1+ Replicated Subobject List (this is a massive perf increase)</li> <li>Added support for slots and slot refs to be owned by any object</li> <li>Removed the ArcInventoryExtras plugin from the github distribution.  This plugin is wildly outdated, and is not useful anymore</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#item-stack","title":"Item Stack:","text":"<ul> <li>Added more functions to control how sub items work with the item stack</li> <li>Added an event that surfaces when sub items change</li> <li>Added Push Model Support</li> <li>Added the ability to query where fragments are coming from in a Find First Fragment and Find All Fragments call.  You can now exclude subitems from FindFirstFragment queries</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#item-slot-container","title":"Item Slot Container","text":"<ul> <li>Added push model support</li> <li>Better (and less buggy) callback ordering for when item slots are deleted</li> <li>Fixed a number of bugs around replicating slots</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#item-slot","title":"Item Slot:","text":"<ul> <li>Added Fake Item replication, which pretends to clients to be a real item (useful for hiding actual loot values from clients until they observe the container)</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#inventory-query","title":"Inventory Query:","text":"<ul> <li>Added a quick way to make a query that matches an item definition</li> <li>Added support for querying against item slot references (Useful for proxy slots)</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#inventory-component","title":"Inventory Component:","text":"<ul> <li>Added info to the Item Slot Update params to indicate if a slot was created or deleted</li> <li>Updated Loot Item to take a preference struct instead of just a query, so that way preference can indicate an exact desired slot</li> <li>Added support for Push Model</li> <li>Added context tag and what processor an event comes from in the event payload</li> <li>Improved BindToAsc logic to actually track the bound ASC and prevent double binding, or even missing an unbind. </li> <li>Added TryFindEmptySlotForItem, which will return the first slot the inventory thinks will hold an item. Using this slot may fail to place the item in the slot if an inventory takes only part of the item (in the case of stacking) </li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#item-definition","title":"Item Definition:","text":"<ul> <li>Added support for Item Defs to add Slot Definitions to item stacks</li> <li>Added Stat Tags to item definitions</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#item-stack-stat-tags","title":"Item Stack Stat Tags","text":"<ul> <li>Added Push Model Support</li> <li>Added a Most Recent Changed Context tag (so we can explain why stat tags have changed)</li> <li>Added RemoveOnZero parameters to SetStack and RemoveStack for Stat Tags, so that you can prevent the tag from being removed when it hits zero.  This is useful now that item definitions provide stat tags.</li> </ul>"},{"location":"arcinventory/changelogs/2.4.0/#item-processors","title":"Item Processors","text":"<ul> <li>Breaking - Inventory Processor Process Loot function has changed signature (again) to support the new preference structure</li> <li>Added push model support.</li> </ul>"},{"location":"arcinventory/concepts/generators/","title":"Item Generators","text":"<p>Item Generators are the factory that produces items.  Because of the need to create Item Stacks and associate them with Item Definitions or Fragments, It becomes fairly involved to create new items on demand.  Item Generators seek to bridge that gap and allow control over the item production process.</p> <p>Most games will not need to use Item Generators.  It is very common for a game to create a single Item Generator, set the Item Definition for it to spawn, and then spawn that item.  This is perfectly fine, and it is recommended for most games starting out using the system.  The Example Project uses this method to generate items.  </p> <p>However, if you need more control over the process of creating items, Arc Inventory gives you a lot of it.</p>"},{"location":"arcinventory/concepts/generators/#basic-setup","title":"Basic Setup","text":"<p>Item Generators require subclassing UArcItemGenerator and overriding the <code>GenerateItemStack_Implementation</code> function.  This can be done in Blueprint.   </p> <p>Inside that function, you simply need to return a <code>UArcItemStackBase</code> pointer.  Most item generators will call <code>CreateModularItemStack</code>, assign an Item Definition and optional Dynamic Fragments, and return it.  </p> <p>Tip</p> <p>You can create as many item stacks as you need in a single generator, which is useful for generating SubItems to attach to your item!  However, you can only return one</p> <p>Arc Inventory contains a few built in item generators, including a Static Item Generator class for embedding into property editors, and a Unique Modular Item Generator for customizing all of the components of item generation in the property editor.  Arc Inventory also provides some item generators designed to select an item generator from a weighted list of possible item generators, which is useful for creating a drop table.  </p>"},{"location":"arcinventory/concepts/generators/#procedural-generation","title":"Procedural Generation","text":"<p>Note</p> <p>The built in Random Generator is not updated for 2.0.  Expect examples of procedural generation of Modular Items in coming updates!</p> <p>Arc Inventory also supports the procedural generation of items through Item Generators.  Given that Item Generators can place any item definition, dynamic fragment, or sub item stack onto an item stack before returning it, an entire procedural system can be created.</p>"},{"location":"arcinventory/concepts/highlevel/","title":"High Level","text":"<p>At the highest level, Arc Inventory is an inventory that allows you to power your game code with GAS, and to give you a lot of power over the design and development of your game.</p> <p>The Inventory System's primary purpose is to give your character and pawns a set of Gameplay Effects, Abilities, and Attributes, and control how and when those are added to and removed from your character's ASC.</p>"},{"location":"arcinventory/concepts/highlevel/#project-goals","title":"Project Goals","text":"<p>Arc Inventory has a few goals, and they are reflected in every part of the inventory system.</p> <ol> <li> Don't Assume Game Design Arc Inventory will not assume your design or make design choices for you.  The core structure can be reused across many genres of game, from RPGs to FPSes to Survival games to Action RPGs. Inventory accomplishes this by breaking up different inventory concepts across the system and classes.  </li> <li> Let the user subclass Arc Inventory attempts to be a general base for GAS powered inventory, but because of #1, it does not make a lot of game design choices like Input or complex UI.  Because of this, every part of the system is intended to be subclasses to fill out features.   </li> <li> The Character Does the Work Arc Inventory makes the character do the work, and is intended to be a component on your character.  Items, ItemDefs, and all pieces are simply bits of information for your character to react to.  Things like how your character actually holds the item or what happens when you activate an item is easily scripted, but must be done on the character or inside of an Gameplay Ability. </li> </ol>"},{"location":"arcinventory/concepts/highlevel/#inventories","title":"Inventories","text":"<p>Inventories are the primary container for Items.  Inventory is an actor component that handles the placement of items into Slots.  </p> <p>Note</p> <p>Inventories components are split into two classes: <code>UArcInventoryComponent</code> and <code>UArcInventoryComponent_Modular</code> (which inherits from <code>UArcInventoryComponent</code>).  The Base Inventory Component handles the management of Inventory Slots and basic inventory operations (such as adding and removing items), while the Modular Inventory Component provides the framework for gameplay integration with inventory data.  It is intended that you use <code>UArcInventoryComponent_Modular</code> for all your gameplay classes.    </p> <p>At it's core, Inventories are an array of <code>Inventory Slots</code>.  Slots are defined with a set of Gameplay Tags, and can have an Item Filter to indicate which items can be placed into the slot.  </p> <p>The Modular Inventory Component is the primary class for the system.  It contains a number of <code>Inventory Processors</code> that provide functionality for the inventory when items are placed into a slot, when items in a slot update, or various other events.</p> <p>Arc Inventory ships with 3 default processors: <code>Bag</code>, <code>Equipment</code>, and <code>Active</code>. </p> <code>Bag Processor</code> The Bag Processor creates a number of slots in the inventory with a shared tag, and sets filters for that tag.  This can be used to create many slots to store items in.  <code>Equipment Processor</code> Equipment Processors listen to for an event when items are placed into specifically tagged slots.  Once an item is placed into that slot, the Processor looks up it's AbilityInfo fragment matching the Equipment Tag and applies the Abilities, Attribute Sets, and Gameplay Effects to the owning actor.   <code>Active Processor</code> The Active Processor collects a list of slots that match the Active Processor's slot query.  It then manages which item slot of that list is \"Active\", as only one item in that list can be active at a time.  When an item is made active, the Processor sends a \"Item Active\" event to the owner, and then looks up the AbilityInfo fragment matching the Active Slot on the item in that slot and applies the Abilities, Attribute Sets, and Gameplay Effects to the owning actor.  This can be thought of as the item currently held by the character in a first person shooter. <p>Item Slots can hold any number of tags, allowing for multiple processors to match the same slot if behaviors are desired there.  </p> <p>Note</p> <p>Wile ArcInventory provides a number of built in processors, you may need to create your own for your own gameplay needs.  Simply subclass <code>UArcItemProcessor</code> in C++ or Blueprint and override any of it's functions to get started.  </p>"},{"location":"arcinventory/concepts/highlevel/#items","title":"Items","text":"<p>Every item instance is represented by a <code>Item Stack</code> UObject.  In a multiplayer scenario, the ItemStack handles replication as a replicated subobject of the actor that owns the inventory that the item is in.  Items not owned by an actor are garbage, and will be garbage collected.</p> <p>Note</p> <p>Items are split into the classes <code>UArcItemStackBase</code> and <code>UArcItemStackModular</code>, which inherits from UArcItemStackBase. <code>UArcItemStackBase</code> contains all of the replication and management code, where UArcItemStackModular contains the properties, fragments, and other higher level functionality bits.  It is recommended that you use <code>UArcItemStackModular</code> in all game code and blueprint.</p> <p>Items contain a list of Fragments, which provide per-item properties to the item.  Fragments can be replicated.  </p> <p>Items may hold a <code>Item Definition</code>, which is a list of fragments shared between all items that share the same definition.  Fragments within an Item Definition cannot be modified and are not individually replicated.</p> <p>Fragments placed onto an Item Stack directly are known as <code>Dynamic Fragments</code>.  They may override fragments placed on the Item Definition.</p> <p>Items may have <code>Sub Items</code>, which are items attached to other items.  SubItems are not a special class.  Any Item can be attached to any other item.  Fragments on sub items may override fragments on parent items, making them useful as attachments, perks, or other gameplay design elements.</p> <p>Note</p> <p>While Arc Inventory provides a number of built in item fragments, it is intended that you create your own for your own gameplay needs, and makes creating new fragments as easy as possible.  </p>"},{"location":"arcinventory/concepts/highlevel/#item-generators","title":"Item Generators","text":"<p>Item Generators are factories for creating items.  An item generator can be as simple as just tying together an Item Definition or as complex as procedurally generating an item with multiple prefixes, suffixes, and random stats.  </p> <p>If you do not plan on creating complicated item generation, randomized items, or other features that may require a more complicated Item Generator, the plugin provides <code>UArcInventoryModularBPFL::QuickGenerateModularItem</code> which will create a new item stack for you using a provided item definition.  Many games exclusively use <code>QuickGenerateModularItem</code> to handle producing every single item stack they will need!</p>"},{"location":"arcinventory/concepts/inventory/","title":"Inventory","text":"<p>Inventory is the primary container for items, and the primary controller for what items do to players.  </p> <p>Inventory is implemented as an Actor Component, and should be added to your actors with the <code>UArcInventoryComponent_Modular</code>.  The base class, <code>UArcInventoryComponent</code> features the core slot structure, placing items into slots, and allowing developers to understand the layout of their inventory through queries.  The Modular Inventory provides the framework for gameplay integration for your inventory.</p>"},{"location":"arcinventory/concepts/inventory/#base-inventory","title":"Base Inventory","text":"<p>The Primary mechanism for the base inventory is to manage and replicate Slots.  It also watches if items move in those slots, and handles the insertion and removal of items</p> <p>The underlying data layout is hidden from implementors, and the public API handles all edge cases around Replication, Ownership, and reports back failure states.</p> <p>The Modular Inventory also provides a bindable \"Inventory Event\" event that observers can bind to.  Whenever the Inventory has a change in data or a Processor has an event that can be responded to, this event is raised with a Gameplay Tag and payload, allowing for gameplay code to respond to changes in the inventory.</p> <p>Warning</p> <p>If a function returns a bool, that means that it can fail.  It is up to you to determine how to handle that failure.  Not catching failure states can lead to Items being lost!</p>"},{"location":"arcinventory/concepts/inventory/#slots","title":"Slots","text":"<p>Slots are the primary container for items.  The underlying replication type, <code>FArcItemSlot</code> is not exposed to the public API, but it covers the details of replication and ensuring that slots are synchronized between client and server.  The public API exposes a <code>FArcItemSlotReference</code>, which contains all the data needed to reference a slot in an inventory.  All functions that refer to inventory slots take a <code>FArcItemSlotReference</code>, and for all purposes, that is the item slot.  </p> <p>Note</p> <p>Always check if the slotref is valid before attempting to access it or pass it into an inventory.  </p> <p>Warning</p> <p><code>FArcItemSlotReference</code> contains a weak pointer to the owning inventory.  If that inventory is destroyed, the slotref will be invalid.  It is not recommend that you store a slotref across multiple frames.  It is recommend that you either strongly control the data lifetime, or query for the slot when you need it.  </p>"},{"location":"arcinventory/concepts/inventory/#slot-queries","title":"Slot Queries","text":"<p>Slot Queries are the concept for accessing data inside of an inventory.  They are represented by <code>FArcInventoryQuery</code>.   They have a number of properties to help find items in your inventory.  You can construct queries with the static functions on <code>FArcInventoryQuery</code></p> <p>The types of queries can be used together to produce a query that targets exact items.  ItemType looks for the item in the slot and matches tags on the item's tags.  ItemType queries automatically fail on slots that are empty.  SlotType Query searches the tags on each slot.  Item Definition queries look for items with the matching item definition.  Each search is mutually exclusive, so you can have a query that is looking for specific items in specific slots.     </p>"},{"location":"arcinventory/concepts/inventory/#slot-filters","title":"Slot Filters","text":"<p>Slot Filters allow designers to indicate what items can be placed into the slot.  Slot Filters contain a GameplayTagQuery to search the tags on a given item, and whether or not to force that slot to contain a single stack.  If there is no TagQuery, the slot accepts all items.</p>"},{"location":"arcinventory/concepts/inventory/#presets","title":"Presets","text":"<p>Inventory settings can be defined in a data asset, <code>UArcInventoryComponentPreset</code>.  These objects allow you to define custom item slots and inventory processors in the asset, and then share that asset across multiple inventory components.  You can also add additional presets to a preset, allowing you to share a set of inventory settings across multiple presets.</p>"},{"location":"arcinventory/concepts/inventory/#notable-functionsproperties","title":"Notable Functions/Properties","text":"<ul> <li> <code>CustomInventorySlots</code> An EditDefaultsOnly Array of Item Slot definitions.  This is where you design out all your slots that have custom functionality.  It is very common to have a dozen or more slots defined here.   </li> <li> <code>CreateInventorySlot</code> / <code>RemoveInventorySlot</code> Protected runtime creation of inventory slots.  It's protected so you can access these by subclassing your inventory, but allows you to create and remove item slots.  Everything replicates fine when creating and removing slots.   </li> <li> <code>PlaceItemIntoSlot</code> Places an item into a slot.  Will fail if the slot already has an item. Always check the return value of this function, and handle failure accordingly.  It is common to call LootItem if PlaceItemIntoSlot fails.  </li> <li> <code>LootItem</code> Places an item into the first slot it can.  The order it checks slots is not guaranteed, so it could end up in slots you don't expect.  If it fails, that means that item cannot possibly fit into the inventory, and failure should be handled. </li> </ul> <p>Caution</p> <p>If placing an item into a slot succeeds, it is recommend to discard the pointer to the item you currently have.  Internally, the Inventory will remap the owner of the items, sometimes duplicating the object (this is to deal with problems with Unreal Replication).  </p>"},{"location":"arcinventory/concepts/inventory/#inventory-processors","title":"Inventory Processors","text":"<p>The Modular Inventory provides a number of Inventory Processors to add functionality to your inventory.  Processors are all derived from <code>UArcInventoryProcessor</code> and have a number of overridable functions and events to watch for changes to the inventory, and respond to them.</p> <p>You can have any number of Processors on an inventory.  You can have multiple copies of the same processor.</p> <p>Arc Inventory has 3 built in processors, although you are encouraged to make your own for your own gameplay needs.  </p>"},{"location":"arcinventory/concepts/inventory/#bag-processor","title":"Bag Processor","text":"<p>The Bag Processor creates a number of \"Bag Slots\", which are slots with a shared item filter.  The number of bag slots can be 0.  The Bag Processor can also set the tags of all the slots it creates.</p> <p>There is a second Bag Processor class that uses a Gameplay Attribute to change the number of bag slots to the value of that attribute when it changes.    </p> <p>Tip</p> <p>If you bind the bag slot gameplay attribute, you can change that attribute with an item!  </p> <p>Tip</p> <p>You can have multiple bag processors with different tags applied to the slots!</p>"},{"location":"arcinventory/concepts/inventory/#equipment-processor","title":"Equipment Processor","text":"<p>The Equipment Processor contains a query for item slots that it uses to respond to item insert and removal events on the inventory.  If an item is placed into a slot that it is watching for, and that item contains an Ability Info fragment that matches a tag set in the Equipment Processor, then the Equipment Processor places the Gameplay Abilities, Attribute Sets, and Gameplay Effects listed onto the owning actor.  If the item is removed, it removes those GAS elements.  </p> <p>Tip</p> <p>Use the Equipment Processor  to hold things like armor in an RPG game, skills in a Overwatch-style hero shooter or MOBA, or stat-stick weapons in a Diablo or Path of Exile style Action RPG!</p>"},{"location":"arcinventory/concepts/inventory/#active-processor","title":"Active Processor","text":"<p>The Active Processor contains a query for item slots that it uses to create a list of slots where it can make one item \"Active\" at a time.  When an item is made \"Active\", the Active Processor looks up the Ability Info fragment that matches the tag set in the Active Processor, and then applies the Gameplay Abilities, Attribute Sets, and Gameplay Effects to the owner actor.  If the Active Item changes, then it removes the previously active item's GAS elements.  The Active Processor also sends an Active Item Changed event to the inventory, allowing the owner to respond to that event.  </p> <p>Tip</p> <p>Use Active Inventories for FPS or RPG games where your character can only hold one item at a time!</p>"},{"location":"arcinventory/concepts/itemstack/","title":"Item Stacks","text":"<p>The second concept is the Item Stack, or Item Instance.  Item Instancing can get very heavy with a lot of data, and Arc Inventory takes care to make each item as light as possible, while still being extendable.  To achieve this, Arc Inventory splits item data into <code>Item Fragments</code>, which can be applied to an Item Stack or an <code>Item Definition</code>.  The Item Stack can query for any Fragment, searching for that fragment in either the Item Stack, Item Definition, or an item's Sub Items (details below).  </p> <p>The Item Definition is a Data Asset that holds a list of Fragments that do not change.  This reduces replication load massively.  While the Item Definition is optional, effective use of Item Definitions allow for efficient networking and memory usage.  </p>"},{"location":"arcinventory/concepts/itemstack/#item-stacks","title":"Item Stacks","text":"<p>Item Stacks are derived directly from UObject, and are replicated inline with the inventory (or other replicated actor who owns the stack).  Item Stacks are as thin as possible, containing the Item Definition, any Dynamic Item Fragments, and the list of Stat Tags.  </p> <p>Warning</p> <p>Internally, Item Stacks are duplicated or moved around, so a pointer to an item stack may expire when transferring items across inventories.  This is to help better support replication, but does mean that it's required to discard pointers to items when transferring item stacks or merging them.</p> <p>Item Stacks have what is known as a Stat Tag array.  This is a list of Tag =&gt; Integer mappings that can be used to measure stack size or any other integer property on an item.  </p>"},{"location":"arcinventory/concepts/itemstack/#fragments","title":"Fragments","text":"<p>Item Fragments are the instanced properties for each item.  They are composable, overridable, and optionally replicated.  To acquire a Fragment, the Item Stack provides query functions named <code>FindFirstFragment</code> and <code>FindAllFragments</code>.  </p> <p>Fragments originating from an Item Definition are known as \"Static Fragments\", and do not replicate (the item definition pointer itself is replicated).  Fragments originating from the Item Stack's fragment array are known as \"Dynamic Fragments\", and can be replicated.  Fragments originating from a Sub Item are known as \"Sub Item Fragments\", and may or may not replicate depending on if the sub item fragment is static or dynamic. </p> <p><code>FindFirstFragment</code> returns the first fragment found that matches the query from either the Sub Item Stacks, The Dynamic Fragments, or the Item Definition (in that order).  This behavior can be used to create overrides for certain Fragments, using Sub Items or Dynamic Fragments to override base properties.</p> <p><code>FindAllFragments</code> returns every fragment that matches the query.  This includes Dynamic Fragments and Sub Item Fragments.  It is up to the user to determine where the fragments came from.</p> <p>Tip</p> <p>Item Fragments can be created in either C++ or Blueprint.  </p> <p>Tip</p> <p>A large amount of item fragments can cause undesirable performance with the garbage collector.  It's best to make larger fragments with lots of properties that all share the same concept.  For example, all the properties needed to show the item in your UI should be placed onto one Fragment</p> <p>Tip</p> <p>Dynamic Fragments are intensive on networking, so for multiplayer games, it's best to limit the number of dynamic fragments used.</p> <p>Note</p> <p>In Arc Inventory 1.0, it was often necessary to access the Item Definition to access properties on an item.  This is no longer needed in 2.0, as the Fragment Queries handle accessing properties.  It is not recommended to access the item definition from an item stack pointer.  </p>"},{"location":"arcinventory/concepts/itemstack/#sub-item-stacks","title":"Sub Item Stacks","text":"<p>Item Stacks can contain a list of Item Stacks as \"Sub Items\".  These are fully functional items with fragments that are attached to the parent item.  Sub Items can be nested indefinitely.  This can be used to create a component system. </p> <p>Sub Items are replicated inline, and every item can have different sub items.  They are ideal for replicating option information with certain item instances.  </p> <p>Fragments on a Sub Item Stack are returned first when querying the parent item's Fragments.  This allows Sub Items to override parent item fragments.</p> <p>Tip</p> <p>Use Sub Item Stacks to implement perks, attachments, or even firing modes on your items!</p>"},{"location":"arcinventory/concepts/itemstack/#item-definitions","title":"Item Definitions","text":"<p>Item Definitions are the static data for items.  They are Data Assets, and are instanced once per game instance and replicated simply as a pointer.  </p> <p>Dynamic Fragments on an Item Stack are returned before Fragments on an Item Definition when querying for fragments.  This can be used to override a Definition's fragment with a dynamic fragment.  </p> <p>Tip</p> <p>Create default values for item names and descriptions in Item Definitions, and override it with a Dynamic Fragment on an item stack!</p> <p>Tip</p> <p>Item Definitions are entirely optional on an item.  While there is quite a bit of network overhead with a fully dynamic item, it's entirely possible.  It works great in single player scenarios!</p>"},{"location":"arcinventory/concepts/itemstack/#world-stacks","title":"World Stacks","text":"<p>Given that Item Stacks are not actors, Items cannot be placed in the game world.  Since this is a common need for inventory systems, Arc Inventory contains a class, <code>AArcItemStackWorldObject</code>, which implements basic replication and visuals for an item. </p> <p>It is recommended that you set up a subclass of this actor, and override the setting in the Project Settings to use it.  You can use <code>UArcItemBPFunctionLibrary::SpawnWorldItem</code> or the <code>Spawn World Item</code> function in blueprint to spawn World Items easily.  </p> <p>Tip</p> <p>If you want different items to behave differently when spawned into the world, you will need to spawn the World Stack yourself, and call <code>SetInventoryStack</code> on it with the item stack you wish to assign.</p>"},{"location":"arcinventory/concepts/ui/","title":"User Interface","text":"<p>User Interface is a common requirement for Inventory systems, but often requires unique and game specific implementations to achieve the best look.  To this end, Arc Inventory provides a few building blocks for development inventories, but expects that user implement their own stylized views.  </p> <p>Arc Inventory follows the MVC pattern for UX, with Inventory/Items acting as the Model, UMG Widgets acting as the View, and Game Framework code like Pawns, the Inventory Component, and Player Controllers acting as the Controller.</p> <p>Tip</p> <p>While you are welcome to modify all of the UMG widgets inside of the Plugin, it is recommended that you copy them out into your own project.  Plugin Updates may overwrite any changes you make.</p>"},{"location":"arcinventory/concepts/ui/#item-slot-widget","title":"Item Slot Widget","text":"<p>Item Slot Widgets are the primary method for showing the contents of an item slot.  Item Slot Widgets can query for a given slot based on some query, or can be given a SlotRef directly on construction.  Once bound to an item slot, it will display the contents of that slot.</p> <p>Info</p> <p>Provided is an example Bag widget, which fills the widget with Item Slot Widgets equal to the number of slots in a bag inventory, and bound to those slots.  It's a good reference for dynamically creating Slot Widgets!</p>"},{"location":"arcinventory/concepts/ui/#item-cards","title":"Item Cards","text":"<p>Items are displayed using an 'Item Card' widget, or a specific UMG subclass that contains a reference to an item and displays the information within that card.  By default, there are two types of Item Cards, Small and Large.  Small Item Cards are generally a 32x32 image displaying the item on top of the item slot widget or while dragging and dropping.  Large Item Cards are used to display the item when you mouse over the Item Card, and often contain all of the data.  The Item Cards look into the Item Fragments for what information to display.</p> <p>It is up to the implementer to create their own displays, but some examples are provided in the plugin.  </p> <p>Tip</p> <p>Arc Inventory ships with a <code>ItemFragment_ItemCard</code> that allows an item to define what item card classes to use.  </p>"},{"location":"arcinventory/concepts/ui/#drag-and-drop","title":"Drag and Drop","text":"<p>Item Slot Widgets implement drag and drop behaviors, allowing for easy swapping of item slots by simply dragging the item to another slot widget.  This is done by way of calling an ability on the player by a tag as defined in the project settings.  </p> <p>Tip</p> <p>More information is located in the Manipulating Items tutorial!</p>"},{"location":"arcinventory/integrations/moveit/","title":"MoveIt","text":""},{"location":"arcinventory/integrations/moveit/#what-is-moveit","title":"What Is MoveIt?","text":"<p>MoveIt's Marketplace Description</p> <p>MoveIt! is a semi-procedural locomotion system for Unreal Engine 4 featuring full network replication and easy integration. MoveIt! is aimed at all game types, and works especially well with shooters or melee games that are camera-facing.</p> <p>MoveIt! was spawned from a need for high quality, replicated, and performance focused locomotion that simply did not exist. Very clean, easy to use, well documented and works flawlessly in multiplayer while being built on top of a solid foundation allowing for on-going updates and improvements.</p> <p>MoveIt! also utilizes multi-threaded animation which is very rare with marketplace assets, and will allow you to have more characters with better performance!</p> <p>You can acquire it here on the Unreal Marketplace</p>"},{"location":"arcinventory/integrations/moveit/#project-setup","title":"Project Setup","text":"<p>To begin integration, ensure that MoveIt is setup according to their documentation</p> <p>MoveIt Project Setup</p> <p>Warning</p> <p>Ensure that <code>\"MoveIt\"</code> is part of your PublicDependencyModuleNames in your build.cs!</p> <p>This document assumes you already have an item definition set up to integrate MoveIt with.  </p>"},{"location":"arcinventory/integrations/moveit/#creating-an-item-fragment","title":"Creating an Item Fragment","text":"<p>Once we've set up MoveIt, it's time to integrate arc inventory.</p> <p>First we're going to create an Item Fragment to hold the MI weapon attachment data.  </p> BlueprintC++ <p>Right click and create a new Blueprint Subclass.  Expand \"All Classes\" and create a new class based on <code>ArcItemFragment</code></p> <p></p> <p>We'll call this <code>BP_ItemFragment_MI</code>.  </p> <p>Once created, add a new variable named <code>WeaponAttachData</code> of the type FMIWeapon.</p> <p>Create a new C++ class that inherits from <code>UArcItemFragment</code> named <code>UMyItemFragment_MI</code>, and create a FMIWeapon property named <code>WeaponAttachData</code></p> <pre><code>UCLASS()\nclass MYGAME_API UMyItemFragment_MI : public UArcItemFragment\n{\n    GENERATED_BODY()\npublic:\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere, Category = \"Attachment\")\n    FMIWeapon WeaponAttachData;\n};\n</code></pre> <p>Once the fragment is created, add it to your item your item definition and configure the properties in the struct.</p> <p>Note</p> <p>MoveIt ships with a Rifle and Pistol animation pose and offset.  Your own custom animations can be placed here, but that is beyond the scope of this tutorial.</p> <p>For more information, refer to the MoveIt Weapon Documentation</p>"},{"location":"arcinventory/integrations/moveit/#setting-up-the-player","title":"Setting Up the Player","text":"<p>In your Character blueprint, create a new Variable named <code>WeaponInfo</code> of type <code>MI Weapon</code>.  This will be where we store the Weapon Info struct from the item.</p> <p>Note</p> <p>You may have done these next few steps as part of the Simple FPS tutorial or your own integration.  The actual steps may vary here.  </p> <p>Next, Create a new Skeletal Mesh component as a child of Mesh.  Name it <code>Held Item Mesh</code>.</p> <p>Then, select your Inventory component and go to \"Events\".  Select OnInventoryEvent and click the big green + button to create an event handler for it.</p> <p>Drag from the \"Even Tag\" pin and create a new \"Switch On Gameplay Tag\" node.  Click the \"Add Node\" button on the node and in the properties window, add <code>Inventory.Event.Activation</code>.  </p> <p></p> <p>From here, drag from out from the Payload pin on the event, and Break that struct.  For an Activation event, if the Item Stack is valid, then that item is being made active.  If the Previous Stack is valid, then that item is being made inactive.  </p> <p>Create a Sequence node from the Activation Tag switch.  In the first element of the sequence, check if Previous Stack is valid, and if so, set your <code>WeaponInfo</code> variable to be empty.</p> <p>In the second element of the sequence, check if the <code>Item Stack</code> property is valid, and if so, call <code>FindFirstFragment</code> and set the class to search for property to be the classname of the fragment you created above.  </p> <p></p> <p>From there, check if the fragment is valid, and if so, set <code>WeaponInfo</code> to be the value of the <code>WeaponAttachData</code> property on the fragment set above.</p> <p>Finally, in Functions, hit Override and override the function <code>Get Weapon Anim Info</code>.  In there, drag in a getter for your <code>WeaponInfo</code> struct and right click on it, select 'Split Struct Pin'. Drag off from <code>Weapon Info Weapon Pose</code> an Is Valid check.  If it is not valid, simply return an empty struct.  If it is valid, create a new Return node, and right click on that and Split Struct Pin.  Connect all the pins from your class's weapon struct to the return node's pins, except the <code>Return Value Weapon Mesh</code> which should be linked to your <code>Held Item Mesh</code> component.</p> <p></p>"},{"location":"arcinventory/integrations/moveit/#conclusion","title":"Conclusion","text":"<p>That is it!  MoveIt will now properly animate your character to hold the weapon.</p>"},{"location":"arcinventory/tutorials/item_manip/","title":"Manipulating Items inside and outside of your Inventory","text":""},{"location":"arcinventory/tutorials/item_manip/#swapping-slots","title":"Swapping Slots","text":"<p>The Primary method to swap items is to activate the built in Swap Item Slots Ability.  This is stored in the ArcInventoryContent folder in your content browser.  </p> <p>Note</p> <p>If you do not see it, you will need to click the little eyeball and enable \"Show Plugin Content\" and \"Show Engine Content\"</p> <p>Swapping Items is done by setting, on the client, the <code>SwapToSlot</code> and <code>SwapFromSlot</code> on the Inventory component, and then activating the ability.  The Ability will then synchronize the FromSlot and ToSlot to the server, and execute the <code>SwapItemSlots</code> function.  This is predicted on the local client, so feedback is instant.</p> <p>Note</p> <p>The default Item Slot Widget will try to activate abilities by the Swap Item Slot tag in the Project settings.  If you cannot get item swapping working, check that your character has that ability, and that tag is set in the project files, and that tag is part of the Ability Tags in the Swap Item Slot ability.  </p> <p>If you are writing your own UI, it is recommended that you set the <code>SwapToSlot</code> and <code>SwapFromSlot</code> properties and then call the ability.  </p> <p>Tip</p> <p>It is recommended that you copy the Swap Item Slots ability out of the plugin and into your project.  Games may need more rules around swapping item slots, and modifying an asset in the plugins folder can be dangerous.</p> <p>You can also create your own SwapItemSlots ability if you want to use your own replication method</p>"},{"location":"arcinventory/tutorials/item_manip/#creating-the-world-item","title":"Creating the World Item","text":"<p>In order for Arc Inventory to represent items in the world, we need to create a Item Stack World Object.  This actor is not an item stack itself, but it holds item stacks for you.   Arc Inventory provides a default implementation that handles replication for you, so we're going to create a blueprint subclass of that and make use of it.</p> <p>Right click in the content browser and create a new blueprint class.  Search for <code>ArcItemStackWorldObject</code> and create a new blueprint of that named <code>BP_WorldItem</code>.  We're going to add some blueprint script to this later, but for now just save and compile the blueprint.</p> <p>Once that is created, open your Project settings, and go to the <code>Arc Inventory Developer Settings</code>.  Find the <code>Item Stack World Object Class</code> setting and set it to be your <code>BP_WorldItem</code>.  Now the plugin will use your blueprinted item whenever a World Item is needed.</p>"},{"location":"arcinventory/tutorials/item_manip/#dropping-items","title":"Dropping Items","text":"<p>Included in the plugin is an ability that will drop an item from an item slot.  This Ability handles all dropping of items by replicating the slot to the server, removing the item from the inventory in that slot, and then spawning a \"World Item\" with that stack as part of it (that we set up above).</p> <p>The removal of items from your inventory is not predicted.  In high latency environments, you will have a delay between the user attempting to drop the item, and the item being removed from the inventory and spawning in the world.   </p> <p>Note</p> <p>The Default Item Slot Widget will attempt to drop an item into the world if the drag and drop operation ends without an underlying Item Slot Widget.  This is done by activating any ability on the owning character with the <code>Item Slot Drop Ability Tags</code>.  As with Swapping, ensure that your character has this ability, that tag is set in the project settings, and the ability has it in it's Ability Tags.</p> <p>If you are writing your own UI, it's recommended that you set the <code>PendingItemDrop</code> property in Inventory and call the ability by tag.  </p> <p>Tip</p> <p>As with the Swap Item Slots ability, it is recommended that you copy this ability out of the plugin and into your project.</p> <p>Also as with the Swap Item Slots ability, you can create your own if you need to.</p>"},{"location":"arcinventory/tutorials/item_manip/#creating-a-simple-interaction-ability","title":"Creating a simple interaction ability","text":"<p>Note</p> <p>This part assumes that your character is set up similarly to the character in the Arc Inventory Example Project.  This part of the tutorial attempts to convey the concepts needed, but your game may want to do this in it's own way.</p> <p>In order to pick up items or interact with other inventories, we need to create a very simple interaction system.  First, we're going to create a simple blueprint interface for interaction.  Right click in your content browser, go to the Blueprints category, and select Blueprint Interface.  We'll name it <code>BPI_Interact</code>.  Rename the first function it creates to \"On Interact\" and add a input parameter of type Actor named \"Interactor\".</p> <p>Next, we're going to create a simple Interact ability.  Right Click in the content browser, go to the Gameplay category, and create a new Gameplay Ability.  Inherity from the base Gameplay Ability, and name it <code>BP_Interact_GPA</code>.  </p> <p>Open the newly created ability, and lets create a simple interaction.  From the Activate Ability node, create a Sequence node.  From the Then 0 pin, create a Commit Ability, and then branch off it's return value.  If True, do a Sphere Trace For Objects.  Create a Get Avatar from Actor Info node, and from that do a Get Actor Eyes View Point.  Wire the Out Location pin to the Start input in the Sphere trace.  Wire Out Rotation to Get Forward Vector, then multiply that by 400.  Add the Out Location vector to the multiplied forward, and then connect that to the End pin in the Sphere trace.  Make an array of Object Types and add set the 0th element to WorldDynamic.  Make an array for Actors To Ignore, and wire the Avatar Actor to the 0th element of that array.  </p> <p>After the Sphere Trace, Wire the Return Value bool to a Branch, and if true, Break the hit result and cast the Hit Actor to BPI_Interact.  Call On Interact on that interface pin, and pass the Avatar Actor to the Interactor parameter.</p> <p>Go back to the Sequence node at the start, and connect \"End Ability\" to the Then 1 Pin.</p> <p>Blueprint Graph</p> <p>Finally, once this ability is created, we want to bind it to input.  While your game may do this differently, The Inventory Example project has a input triggered starting abilities map that we'll add this ability to, and bind it to the \"Interact\" Enhanced Input Action</p>"},{"location":"arcinventory/tutorials/item_manip/#pick-up-an-item","title":"Pick up an item","text":"<p>For picking up items, we're going to use the Interact ability and interface that we created, and the World Item we also created.  </p> <p>Open up <code>BP_WorldItem</code>, and go to Class Settings (you may need to open the full blueprint editor).  In the <code>Interfaces</code> Category, we want to click the \"Add\" drop down in the Inherited Interfaces section and type in and select <code>BPI_Interact</code>.  Now, we have a On Interact function we can implement, so lets do that.  Right click on that function and create the implementation.</p> <p>From that On Interact node, we want to create a Switch Has Authority node, and from the Authority pin we want to Get Component By Class using the Arc Inventory Component Modular class.  Check if it's valid, and if so, call Loot Item on that component, getting the Inventory Stack from the world item for the Item pin.  We'll leave Event Tag empty.  From the Return Value of Loot Item, we want to branch, and if True, Destroy the actor.  </p> <p>Blueprint Graph</p> <p>Now when we interact with the world item, the item will be placed into our inventory!</p>"},{"location":"arcinventory/tutorials/item_manip/#create-a-container","title":"Create A Container","text":"<p>Any Actor can hold an Inventory Component.  Item Stashes or Chests are a good example of an actor that can hold many items.</p>"},{"location":"arcinventory/tutorials/item_manip/#create-a-container-actor","title":"Create a Container Actor","text":"<p>To Start, Create a new Actor, which we will call <code>BP_ExampleChest</code>.  Give that Actor some visuals (A cube will suffice, but I use the fantastic KennyNL assets) and a Modular inventory component.  Give the Inventory a Bag Processor and 12 slots.</p> <p>Warning</p> <p>For this to work in Multiplayer, ensure that both the Actor and it's Inventory are set to replicate!</p> <p>Open up the Class Settings, and much like the World Item, add the <code>BPI_Interact</code> interface to this chest.  </p> <p>Next, we want to create a property on the chest named <code>StartingItems</code>, and set it to be the <code>Arc Starting Item</code> struct type, and right click on it so that it's an Array.  Set it to Instance Visible (the eye icon).</p> <p>From there, we want to add some code to Begin Play so we spawn these starting items into the chest.  From Begin Play, add a Switch Has Authority node, and from Authority we want to do a For Each Loop.  The Array will be our <code>Starting Items</code> property.  From Array Element, Break the starting item entry struct, and from Item Generator call Generate Item Stack.  From the Context pin, make a ArcItemGeneratorContext struct but don't worry about setting any of the properties.  From the Return Value of the Generate Item Stack function, we want to call Loot Item on our Inventory, and feed the results of Generate Item Stack into it's Item field.  </p> <p>Blueprint Graph</p> <p>Place this actor in the world.  This is our stash that will hold our items.  You can add items to the starting items in the actor properties in the world.  </p>"},{"location":"arcinventory/tutorials/item_manip/#create-a-view-widget","title":"Create a View Widget","text":"<p>Now, we need to be able to inspect it.  We must create a UMG widget to view this container.  Create a new widget that we'll call <code>WBP_SampleChestView</code>.  Lay out the widget however you want, but I went with a simple black border.  </p> <p>In the content of the widget, Add in a <code>BP_InventoryBagWidget</code> to your widget.  This widget will display the contents of any inventory with slots that match the bag tag.  </p> <p>Tab over to the Graph for the widget, and create a new blueprint event.  We'll name this <code>Bind</code> and make sure it has a Arc Inventory Component input parameter.</p> <p>From that event, we want to grab the Inventory Bag Widget property and call Set Target Inventory on it.  Give it the value of the Bind event parameter.  Then, we want to call Refresh on it.  </p> <p>Blueprint Graph</p> <p>Info</p> <p>I also added a \"Close\" button to my widget, that removes the widget from parent.  You may want to control interaction differently.</p>"},{"location":"arcinventory/tutorials/item_manip/#interaction","title":"Interaction","text":"<p>Next, we need to interact with a chest to view it's contents.  Go back to the <code>BP_ExampleChest</code> blueprint.</p> <p>Since we implemented the BPI_Interact interface, we simply need to, on interaction, display this UI widget.  Right click on the On Interact interface function and implement it.  From that, lets Create a widget, passing in our <code>WBP_SampleChestView</code> widget.  Owning Player is going to be Player Controller 0.  From that widget, we want to call the Bind function we created, and then Add it to viewport.  </p> <p>Blueprint Graph</p> <p>From here, you can set the Input Mode and show the mouse cursor, but your game may handle UI input it's own way </p> <p>Tip</p> <p>Lyra has a Common UI Implementation that makes this part very easy!</p>"},{"location":"arcinventory/tutorials/item_manip/#transfer-items-between-two-inventories","title":"Transfer Items between Two Inventories","text":"<p>Simply dragging the item between your inventory and the target inventory should work via Drag and Drop.</p> <p>The Inventory takes any two inventory slots to transfer items to/from.  So long as one of the slotrefs reference a slot in the player's inventory, it will swap between the two inventories.  </p> <p>Caution</p> <p>The default implementation does not check if a player should be transferring items between two inventories.  It is up to you to implement these checks</p>"},{"location":"arcinventory/tutorials/simplefps/","title":"Arc Inventory Tutorial","text":"<p>How to create a simple inventory with an item held in your hand</p>"},{"location":"arcinventory/tutorials/simplefps/#part-0-setup-arc-inventory","title":"Part 0: Setup Arc Inventory","text":"<p>This Tutorial assumes you've setup the inventory plugin and have it working.  It also assumes you have some form of Ability for a weapon.  You can use the FPS shoot ability from the example.</p> <p>This Tutorial assumes you have a Player Pawn and the Ability System is setup for it.  Refer to the GASDocumentation by tranek for tips and strategies to set that up.</p> <p>This Tutorial assumes you are familiar with Gameplay Tags and Gameplay Tag Queries.  Please refer to the Unreal Engine Gameplay Tag documentation for more information.</p> <p>For the UI Section of the tutorial, it assumes you are very familiar with UMG.  </p> <p>This Tutorial uses a mix of C++ and Blueprint.  C++ code will be denoted by a C++ code block like so:</p> <pre><code>Code()\n</code></pre> <p>No C++ code is guaranteed to compile or work.  Examples are for illustration of the point.</p> <p>Blueprint will be described (may add images later).</p> <p>Note</p> <p>Ensure that in the Arc Inventory Settings in the Project Settings, appropriate tags are set for the Bag Slot, Equipment Slot, and Active slot. </p>"},{"location":"arcinventory/tutorials/simplefps/#part-1-setup-the-inventory","title":"Part 1: Setup the Inventory","text":"<p>In your player pawn, Implement the <code>IArcInventoryInterface</code> from \"Interfaces/ArcInventoryInterface.h\".  Do so like this:</p> <p>YourCharacter.h <pre><code>UCLASS()\nclass YOUR_API AYourCharacter : public ACharacter, public IArcInventoryInterface /* ASC Interfaces here too */\n{\n    GENERATED_BODY()\n    //Your character class stuff...\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\n    class UArcInventoryComponent_Modular* InventoryComponent;\npublic:\n    static FName InventoryComponentName;\npublic:\n    AYourCharacter(const FObjectInitializer&amp; ObjectInitializer);\n    class UArcInventoryComponent_Modular* GetInventoryComponent() const override { return InventoryComponent; }\n};\n</code></pre></p> <p>YourCharacter.cpp <pre><code>    FName AYourCharacter::InventoryComponentName(TEXT(\"InventoryComponent\"));\n\n    AYourCharacter::AYourCharacter(const FObjectInitializer&amp; ObjectInitializer)\n        : Super(ObjectInitializer)\n    {\n    ///Your Character stuff\n        InventoryComponent = CreateDefaultSubobject&lt;UArcInventoryComponent_Modular&gt;(InventoryComponentName); \n    }\n</code></pre></p> <p>Next, create a new Blueprint Class that is a child of <code>AYourCharacter</code>, named BP_YourCharacter.  Verify that you have an Inventory Component on your character.</p>"},{"location":"arcinventory/tutorials/simplefps/#part-2-creating-item-slots","title":"Part 2: Creating Item Slots","text":"<p>Arc Inventory makes a very clear distinction between underlying data and the visual representation of that data.  This allows for separation of work for larger teams, but also for quick iteration of doing temp UI to get design down.  </p> <p>We'll start with adding item slots.  Our goal will be to create an inventory layout similar to the screenshot on the marketplace for Arc Inventory.  For that, we have the following:</p> <ul> <li>Primary Weapon</li> <li>Secondary Weapon</li> <li>Head Armor</li> <li>Body Armor</li> <li>Passive Slot 1</li> <li>Passive Slot 2</li> <li>12 Bag slots</li> </ul> <p>The Primary Weapon and Secondary Weapon slots can hold Active Items (IE: weapons that can be held in the character's hand), and for the sake of this tutorial, we'll say that only Pistols can go in the Secondary Weapon slot and any active items can go into primary.  Head and Body armor require items that fit directly in that slot, but Passives can hold any passive item except Head and Body armor.  N Bag Slots means that you have any number (lets say 12) slots that can hold any item, but if the item is in that bag slot it does nothing. </p> <p>To Achieve these different behaviors, we need to add <code>Inventory Processors</code> to the inventory.</p> <p>Open BP_YourCharacter and navigate to the Inventory Component on it.  There, you will see an array of Inventory Processors.  We want to add 3 processors, Bag Processor, Equipment Processor, and Active Processor.  We'll use the default tags for each for this tutorial.</p> <p>Tip</p> <p>The Bag, Active, and Equipment processors allow for you to set the slot tags they will look for.  We're going to use the default values for this tutorial. </p> <p>For the 12 bag slots, we need to configure the Bag Settings.  Set the property to to 12.  This will give us our Bag Slots.</p> <p>Tip</p> <p>There is a Bag Processor that allows for binding to a Gameplay Attribute.  While we wont cover it in this tutorial, if you want a resizable bag, this is a good way to do that!</p> <p>From there, in the Inventory Layout section, Create 6 array elements.  These will be our custom slots.</p> <p>In slot 0, we want to have a primary weapon.  So, in the Tags, Give the slot the Active item tag <code>Inventory.Slot.Active</code> and the Equipment tag <code>Inventory.Slot.Equipment</code>.  This will denote this slot as both an Active and Equipment slot, and those behaviors will activate when an item is placed into this slot.  We also want to indicate that this is the 'Primary Weapon' slot, so create a new tag <code>Inventory.Slot.PrimaryWeapon</code> and give it to this slot.  </p> <p>In this slot's filter, we want to create Filter Query that accepts <code>ANY(Inventory.ItemType.Weapon)</code>, and check 'Force Single Stack'.  This will cause the Inventory to check if any item attempting to be placed into this slot contains the <code>Inventory.ItemType.Weapon</code> tag, and it will only accept items with 1 stack.  We'll set the items up later.  </p> <p>Secondary Weapon is similar to Primary weapon.  Give it the Active and Equipment tags, and create a tag named <code>Inventory.Slot.SecondaryWeapon</code> and grant it.  In the filter, create a query that checks for the <code>Inventory.ItemType.Weapon.Pistol</code> tag to ensure that only pistols can be placed in this slot.  </p> <p>For Head and Body Armor, we want to set the Tags to be have the Equipment Tag, and a tag for it's name (ie <code>Inventory.Slot.HeadArmor</code>).  In the Filter, Ensure that the query is looking for <code>ANY(Inventory.ItemType.Passive.Head)</code> and Body respectively.  We also want to force single stack.</p> <p>The passive slots are similar, however they do not need unique tags to identify them.  Give them the Equipment Tag, and give them both the <code>Inventory.Slot.Passive</code> tag, and ensure that their filters only allow passive items (perhaps <code>ANY(Inventory.ItemType.Passive) AND NOT(Inventory.ItemType.Passive.Head OR Inventory.ItemType.Passive.Body)</code>)  Slots do not need unique tags, and since any valid item can be placed in either slot.  If we wish to find specific items later in code, we can query for different information.  </p> <p>With this, the data is set up for this inventory layout.  Now lets create a few items to put into these slots</p>"},{"location":"arcinventory/tutorials/simplefps/#part-3-create-the-items","title":"Part 3: Create the items","text":"<p>Since we already created the slots, we have an idea what kinds of items could possibly exist.  From here, lets create some weapons.  </p>"},{"location":"arcinventory/tutorials/simplefps/#weapons","title":"Weapons","text":"<p>First we need to create a new Item Definition for our first item, a Rifle.  Right click in the content browser and go to New -&gt; Miscellaneous -&gt; Data Asset.  Select <code>ArcInventoryModularItemDef</code>.  Lets name this BP_Rifle_ItemDef.  </p> <p>Note</p> <p>Item Definitions are a collection of static item data that can applied to items.  They allow us to define 'classes' of items, and share bits of data between many item instances.  </p> <p>In the Definition Tags variable, set the container to have <code>Inventory.ItemType.Weapon.Rifle</code>, and any other tags you wish to describe this weapon.  I have seen setups with 10+ tags to describe each weapon, and there is very little cost to having many tags on an item.  When this Item Definition is associated with an Item Stack, the Item Stack will return these tags.</p> <p>Next, we need to give this definition some Fragments.  There are a few fragments we want to add, but you can add as much data here as you need, or even create your own custom fragments.  For this tutorial, we're just going to add some basic behavior for the item to act as a weapon, a model, a name, and a description.  </p> <p>Add the following Item Fragments to the definition's Fragments Array:</p> <ul> <li><code>ArcItemFragmentAbilityInfo</code> <ul> <li>This fragment will give the item behaviors.  Without an AbilityInfo, no GAS elements are placed on the weapon.   We want to mark this specific Ability Info Fragment as the one used for the Active Processor, so we want to put the <code>Inventory.Slot.Active</code> tag on it.  Here we also want to give it our Shoot Ability.  There is a few example abilities in the Arc Inventory Example Project.</li> </ul> </li> </ul> <p>Tip</p> <p>The Ability Info fragment is extremely flexible and allows for creating many different gameplay behaviors using GAS.  Many games will place Weapon-specific attribute sets in the Active Ability Info to apply attributes to the player to manage things like rate of fire, recoil, cone of fire, ammo, and much more!</p> <ul> <li><code>Arc Item Fragment Skeletal Mesh</code><ul> <li>This fragment will give us a visual mesh to hold and in the world.  Select a weapon mesh, and add <code>Item.Fragment.Mesh.Held</code> and <code>Item.Fragment.Mesh.World</code> to the fragment tags.</li> </ul> </li> </ul> <p>Tip</p> <p>Arc Inventory provides a Static Mesh fragment if you want to use static meshes.  You can also add a second mesh fragment and give it one of the Held or World tags to make the world item appear different than the held item.</p> <ul> <li><code>Arc Item Fragment Text</code><ul> <li>We want to give the item a basic name, so we'll name this \"Rifle\" and give it the tag <code>Item.Fragment.Text.Name</code>.  </li> </ul> </li> </ul> <p>Tip</p> <p>Arc Inventory also ships with a Description field by default.  It is optional.</p> <p>Tip</p> <p>While this tutorial will not cover Dynamic Fragments, you can override the name (or any of these fragments) on a per-item stack basis by adding a Dynamic Fragment to that item stack with the same tag as a fragment on an item definition.</p> <ul> <li><code>Arc Item Fragment Item Card</code><ul> <li>We want to add two of these fragments.  This will let us define the Large Item Card (or tooltip) and the Small Item Card (the icon in the UI). The first one we'll set the ItemCardWidget to <code>BP_SimpleSmallItemCard</code> and the tag <code>Item.Fragment.UI.ItemCard.Small</code>. For the second, we'll set the ItemCardWidget to <code>BP_SimpleLargeItemCard</code> and the tag to <code>Item.Fragment.UI.ItemCard.Tooltip</code>.  These two widgets will look up data from the item stack and display it.  </li> </ul> </li> </ul> <p>Tip</p> <p>You can design your own widgets for displaying tooltips or small item icons.  Just replace the widgets in the Item Card fragments!</p> <ul> <li><code>Arc Item Fragment Texture</code><ul> <li>We want to give this item an Inventory Icon.  Set the Texture to something that looks like a rifle (The example project has a texture from GameArtIcons).  Set the tags to <code>Item.Fragment.UI.Icon</code>.</li> </ul> </li> </ul> <p>And that's it.  The Weapon is now composed.  </p> <p>Once you are happy with this item, Duplicate this item, name it <code>BP_Pistol_Def</code> and change it's Definition Tag to have <code>Inventory.ItemType.Weapon.Pistol</code>.  This will go in the secondary slot.  </p>"},{"location":"arcinventory/tutorials/simplefps/#equipment","title":"Equipment","text":"<p>Similar to weapons we want to create some new blueprint classes here.  For this, we'll want to create new item definitions the same way as we created the active items above.  In fact, most of the properties are the same, so we can just duplicate them and change properties.  </p> <p>Unlike weapons, where we wanted the ability info to be applied to the player when the item is active, with equipment we want the ability info to be applied when an item is placed into an equipment slot.  To do so, we simply need to change the Ability Info fragment tag above to <code>Inventory.Slot.Equipment</code>.  This will allow the Equipment Processor to place these GAS elements onto the player when the item is placed into an equipment slot.</p> <p>In the Gameplay Effects part of the Ability info, go ahead and give them a Gameplay Effect that changes some properties.  A simple example that changes a single property can be found in the Example Project.</p> <p>Tip</p> <p>An item can have Fragments for both Active and Equipment behaviors!  Just create two fragments, giving one of them the Active tag and the other the Equipment tag.</p> <p>In our Definition Tags, we want to give our equipment some tags to describe the item.  We created a few tags when we created the item slots, so make sure you use those tags to describe head and body armor.</p>"},{"location":"arcinventory/tutorials/simplefps/#part-4-ui","title":"Part 4: UI","text":"<p>This will be very light, as UI is a very complex topic and this is a getting started tutorial.  </p> <p>Create a new blueprint widget for your inventory.  Split the widget in half using a Vertical Box, with the top half being a Canvas Panel and the bottom half a <code>BP_InventoryBagWidget</code> (Note: this is in the ArcInventory plugin.  You should duplicate it into your project if you wish to edit it)</p> <p>In the top half, place a number of BP_ItemSlotWidgets into the Canvas Panel equal to the number of unique item slots you have.  In the details panel for each of those ItemSlotWidgets, you will see an 'Item Slot Query' property.  In the Slot Type Query field, fill out th Gameplay Tag Query to query the specific slot for each widget (for example, for one of your slots you may want to query <code>ANY(Inventory.Slot.PrimaryWeapon)</code> to make that ItemSlotWidget show what is in the primary weapon slot).</p> <p>From there, consult the Example Project for how to set up responding to Drag and Drop (it's automatically set up with BP_ItemSlotWidget) and how to represent your item in the UI (also, automatically set up).  </p>"},{"location":"arcteams/","title":"Home","text":"<p>Welcome to the Arc Teams Documentation Portal!</p>"},{"location":"arcteams/#description","title":"Description","text":"<p>Arc Teams is a networked multiplayer solution that allows for the creation of Teams and other segmentation methods for players.</p> <p>Arc Teams was built from the ground up to support networked multiplayer games. It powers multiple games, each with different styles of segmenting players. ArcTeams supports both runtime and design time Team Definitions, allowing you to create any type of Team. </p> <p>Arc Teams also supports a concept of \u201cSub Teams\u201d, which are teams within teams. This can be used to further segment players into Squads, Fireteams, Guilds, Factions, or whatever you need for your game. Arc Teams has a small development footprint and integrates simply into any code base. Simply override a few functions in GameMode and add a component to PlayerState, then it works! </p> <p>Get it on the Unreal Marketplace: Marketplace Page</p>"},{"location":"arcteams/#technical-details","title":"Technical Details","text":"<p>Features:</p> <ul> <li>Create Static or Dynamic Teams at runtime or in editor!</li> <li>Plug and play with any existing design</li> <li>Fully networked </li> <li>Create SubTeams to further segment players</li> <li>Easily associate objects in the game world with teams</li> </ul> <p>Still need help?</p> <p>You can get support in our discord!</p> <p>Discord.gg/PunyHuman</p> <p>Plugin channels:</p> <ul> <li>#plugins-general</li> <li>#plugins-support</li> </ul>"},{"location":"arcteams/debugaids/","title":"Debug Aids","text":"<p>This Page contains all of the console commands and tools for debugging the system and gaining a better understanding of it's functionality.  Debug tools are not intended for normal use and may be unstable, and your milage may vary.  </p> <ul> <li> Console Command: <code>ShowDebug Team</code> Shows a debug overlay, listing all teams, subteams, and players in those teams.  It takes server replicated strings so it is showing the authority state of the teams system </li> </ul>"},{"location":"arcteams/initialsetup/","title":"Initial Setup","text":"<p>Thanks for purchasing Arc Teams!  Once you've downloaded the plugin and enabled it in your project, this is how you start to use it!</p>"},{"location":"arcteams/initialsetup/#configuring-the-plugin","title":"Configuring the Plugin","text":"<p>Once the plugin is installed and enabled, the next step is to add the Gamemode Component to your gamemode.  This component is the driver for the entire system, and is what manages everything.  Let's add one to our Gamemode to enable configuration and start making teams!</p> C++Blueprint <p>In your Gamemode class, add the the component to your gamemode and implement the <code>IArcTeamInterface_Gamemode</code></p> <p><code>MyGameMode.h</code> <pre><code>#include \"Interfaces/ArcTeamInterface_Gamemode.h\"\n\nclass UArcTeamComponent_Gamemode;\n\nclass MYGAME_API AMyGameMode: public AGameMode, public IArcTeamInterface_Gamemode\n{\n    GENERATED_BODY()\n\n    private:\n        UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\n        UArcTeamComponent_Gamemode* TeamComponent;\n\n    public:\n        AMyGameMode(const FObjectInitializer&amp; ObjectInitializer);\n\n        virtual UArcTeamComponent_Gamemode* GetTeamComponent() const override\n        {\n            return TeamComponent;\n        }\n\n        virtual AActor* ChoosePlayerStart_Implementation(AController* Player) override;\n\n        virtual bool ShouldSpawnAtStartSpot(AController* Player) override;\n};\n</code></pre></p> <p><code>MyGameMode.cpp</code> <pre><code>AMyGameMode::AMyGameMode()\n: Super()\n{\n    TeamComponent = CreateDefaultSubobject&lt;UArcTeamComponent_Gamemode&gt;(TEXT(\"Team Component\"));\n}\n\nAActor* AMyGameMode::ChoosePlayerStart_Implementation(AController* Player)\n{\n    return ChooseTeamPlayerStart(Player);\n}\n\nbool AMyGameMode::ShouldSpawnAtStartSpot(AController* Player)\n{\n    return Super::ShouldSpawnAtStartSpot(Player) &amp;&amp; GetTeamComponent()-&gt;CanUsePlayerStartForPlayer(Player, Player-&gt;StartSpot.Get());\n}\n</code></pre></p> <p>Once this is made, create a new Blueprint for this team class.</p> <p>Warning</p> <p>Remember to add <code>ArcTeams</code> to your build.cs!</p> <p>For Blueprint, Arc Teams contains a base class <code>ArcTeamGamemodeBase</code>.  Simply create a new blueprint from that class or reparent your gamemode to it</p> <p>Note</p> <p>It is currently not possible to add a team gamemode component in blueprint.  This is because some functions need to be overriden in AGameMode and you cannot override them in blueprint.</p> <p>It is highly recommended that you follow the C++ path for this section to set up your gamemode.  </p> <p>Once the component is added, you need to configure the teams in the component.</p> <p>Open your Gamemode blueprint and inspect the Team Component that is part of it.  Within it contains a number of configuration properties for setting up teams.  </p> <p>For now, we are going to modify the <code>Default Teams</code> array to add two teams, a Red Team and a Blue Team.  Add two array elements and se their Instance Tags to <code>Team.Slot.Red</code> and <code>Team.Slot.Blue</code> respectively.  We will return to this to set their TeamDefinitions, but Team Class remain <code>none</code> as we are not changing the underlying Team Instance in this tutorial.</p> <p>Info</p> <p>The Instance Tags property makes use of Unreal Engine's Gameplay tag system.  More information can be found here: Unreal Engine Documentation</p>"},{"location":"arcteams/initialsetup/#creating-team-definitions","title":"Creating Team definitions","text":"<p>In the editor, we need to create a pair of team definitions for Red Team and Blue Team.  Create two blueprints that inherit from <code>ArcTeamDefinition</code>, <code>BP_TeamDef_Red</code> and <code>BP_TeamDef_Blue</code>.  </p> <p>In the Red team blueprint, we will set the Owned Tags property to contain the <code>Team.Side.Red</code> tag (Create it if it doesn't exist) and in the UI Data property, set it's type to <code>Arc Team UIObject Team Definition</code>.  Set it's name to <code>Red</code> and the color to a reddish color.  </p> <p>For Blue Team, do the same, but change the names to Blue and the color to Blue.  </p> <p>Head back to our gamemode, and within the Default Teams array, set the first element's TeamDefinition to Red and the second's to Blue.  </p> <p>Info</p> <p>Team Definitions are a data-only object that provide all the static data for a given team.  For more information, check the Team Definition Concepts page!</p>"},{"location":"arcteams/initialsetup/#putting-players-into-teams","title":"Putting Players Into Teams","text":"<p>Putting players into teams is fairly straightforward, and Arc Teams provides an automatic way to assign players to teams if your game wants to do that.  If, in the Gamemode Component <code>Auto Assign New Players</code> is checked, then when a player joins the game they will be assigned automatically to any team that has <code>Auto Joinable</code> checked in it's team definition.</p> <p>However, if you want players to be manually assigned to a team, you can do so by calling <code>PlayerRequestJoinTeam</code> on the GameMode component with that player's PlayerState component.</p> <p>Tip</p> <p>PlayerState Components are automatically placed on characters.  You can get a player's PlayerState Component easily by calling <code>UArcTeamsBlueprintLibrary::GetPlayerStateComponentFromPlayer</code> in C++ or that same function in Blueprint.  It takes the PlayerController.  </p> <p>It is recommended, for performance reasons, that you manually add the PlayerState Component to your player state object, but ArcTeams will automatically do it for you if you forget or want to get the plugin up in running fast.</p>"},{"location":"arcteams/initialsetup/#conclusion","title":"Conclusion","text":"<p>That's it!  Now you have a working team system!</p>"},{"location":"arcteams/changelog/1.2.1.86/","title":"1.2.1.86","text":""},{"location":"arcteams/changelog/1.2.1.86/#the-initial-marketplace-release","title":"The Initial Marketplace Release","text":"<ul> <li>Initial Marketplace Release</li> </ul>"},{"location":"arcteams/changelog/1.3.0.98/","title":"1.3.0.98","text":""},{"location":"arcteams/changelog/1.3.0.98/#the-one-that-supports-427","title":"The one that supports 4.27","text":"<ul> <li>Removed Win32 support, as UE will no longer support it</li> <li>Fixed a bug where subteams were in the team list when \"include subteams\" was false</li> <li>Fixed not spawning on default spawns after teams change</li> <li>Allow blueprinting of ArcTeamJoinRequirement</li> </ul>"},{"location":"arcteams/changelog/1.3.1.105/","title":"1.3.1.105","text":""},{"location":"arcteams/changelog/1.3.1.105/#the-one-that-supports-50-and-51","title":"The one that supports 5.0 and 5.1","text":"<ul> <li>Added 5.0 and 5.1 support<ul> <li>Note: There is no Iris support in 5.1.  That will come at a future date.</li> </ul> </li> <li>Fixed the tag container containing duplicate tags due to blueprint caching when calling Get Owned Gameplay Tags on a Team</li> <li>Fixed a crash when trying to access a player controller</li> <li>Fixed a warning about SetReplicates in the constructor</li> <li>Added the team tags to the ShowDebug Teams display</li> </ul>"},{"location":"arcteams/changelog/1.4.0/","title":"1.4.0","text":""},{"location":"arcteams/changelog/1.4.0/#the-one-that-updates-to-50","title":"The one that updates to 5.0","text":""},{"location":"arcteams/changelog/1.4.0/#version-naming-scheme-change","title":"Version Naming Scheme Change","text":"<p>Starting with 1.4.0, the version scheme has changed.  The Version Scheme now matches closer to SemVer, with Major.Minor.Patch-githash.  The Githash replaces the old changelist number in the previous version.  Note: If you access Arc Teams on the Puny Human Github, the version will always be Major.Minor.X-git, for all major/minors.  I do not update the patch or githash for git distributions.  </p>"},{"location":"arcteams/changelog/1.4.0/#changenotes","title":"Changenotes","text":"<ul> <li>Updated plugin to support 5.0, 5.1, and 5.2</li> <li>Fixed the DisplayDebug Crash in 5.2</li> <li>Added Replicated Subobject support for 5.1+</li> <li>Added IsPlayerInTeam helper function to ArcTeam</li> <li>Fixed a bug where in server context, OnTeamAdded would fire before a parent team was set, leading the server to believe that subteams were primary teams.</li> </ul>"},{"location":"arcteams/concepts/highlevel/","title":"High Level","text":"<p>High level, Arc Teams is a player segmentation system, and a way to tag players into groups and teams.  </p>"},{"location":"arcteams/concepts/highlevel/#project-goals","title":"Project Goals","text":"<p>Arc Teams has a few goals, and they are reflected within the Teams System</p> <ol> <li> Don't assume Game Design Arc Teams does not assume your game design.  It's core structure is a player segmentation system that allows players to be put into different teams, and then allow those teams to operate among themselves and among the players. </li> <li> Let the user Subclass Arc Teams does not implement game design, so design must allow users to subclass as much as possible to add functionality to teams and players within them.  Every part of Teams can be subclassed, functionality extended, and game design can be implemented with ease. </li> <li> The Components do the work Arc Teams introduces a number of components that do the work for the system.  By isolating the implementation details into components, team interaction can grow, be tested, and improve without negative code patterns forming. </li> </ol>"},{"location":"arcteams/concepts/highlevel/#team-components","title":"Team Components","text":"<p>The primary driver of Teams is a collection of components that are placed onto certain Gameplay Framework objects, such as the GameMode, Game State, and Player States.  Each component has a primary function that drives certain parts of the team and segmentation logic.  </p> <p>The GameMode component is the authoirty of the system.  It handles the creation and destruction of all teams, the segmentation of players, and executing the rulesets for players joining and leaving those teams.  </p> <p>The GameState Component is the replication owner for all ArcTeams primitives.  It handles the transfer of teams to all players and provides a common starting point for UI to display information about the teams.</p> <p>The Player State Component handles the association of Player to Team, and the per-player state for the system.</p>"},{"location":"arcteams/concepts/highlevel/#teams","title":"Teams","text":"<p>Teams are a tree-like UObject that is replicated to all players.  Players are associatied with Teams, forming the backbone of the segmentation system.</p> <p>Teams can have any number dependent Teams, known as SubTeams.  Those SubTeams can have further SubTeams, allowing for segmenting players within a given Team.  Teams without a parent Team are known as Primary Teams.</p> <p>Tip</p> <p>Use Subteams to create features such as Squads or Fireteams!</p> <p>Teams have an associated default-object only object known as a Team Definition, that contains static data for that Team.  This data is not replicated, and can be used to store UI information that does not need to be sent to the clients for a Team.  </p>"},{"location":"arcteams/concepts/highlevel/#team-states","title":"Team States","text":"<p>Some data requires a full actor channel to replicate effeciently, so Teams may create Team State actors to handle the replication to clients.  Team States come in two flavors, the Public Team State, and the Private Team State.  Public Team States are replicated to all players in a server, and Private Team States are replicated to only members of that team. </p> <p>Tip</p> <p>Use Public Team States for replicating data such as the Score, Respawns, or other game state that all players must know.  You can use the Private Team State to replicate information only available to a Team, such as Resources, Team Orders, or even collections of team associated objects like buildings.</p>"},{"location":"arcteams/concepts/team/","title":"Teams","text":""},{"location":"arcteams/concepts/team/#teams","title":"Teams","text":"<p>Teams are the primary object segment players, represented by the UArcTeam object.  Teams are a Replicated UObject that are sent to all players through the Game State Component. </p> <p>Teams are extremely thin, small objects, and players have one Primary Team and many SubTeams.  Teams can only be created by the Game Mode Component. </p> <p>By default, each player is assigned to a Primary Team upon joining a server.  A player may only be in one Primary Team, and must leave their Primary Team before joining a new one.  Players may also not have a Primary Team, and are considered Unassigned.  A Spectator Team is also created by default, and any player placed into Spectator by AGameMode is placed into that spectator team. </p> <p>Info</p> <p>The auto assignment behavior can be modified easily by unchecking 'Auto Assign New Players' in the Game Mode Component.</p>"},{"location":"arcteams/concepts/team/#join-requirements","title":"Join Requirements","text":"<p>By Default, Arc Teams does not implement any mechanism to ensure that players should join teams.  To that end, a class, UArcTeamJoinRequirement, exists with an implementable method in C++ or Blueprint to implement rules around joining any team.  </p>"},{"location":"arcteams/concepts/team/#sub-teams","title":"Sub Teams","text":"<p>All Teams (including SubTeams) may have any number of Sub Teams, which are simply UArcTeam objects added to a parent team.  A player may join any SubTeam, so long as the join is approved by that team's Join Requirements.  </p> <p>Subteams are useful for further segmenting players, and are used for features such as Squads, Parties, and similar segmentation within a team.</p> <p>Note</p> <p>By Default, Arc Teams does not require a player be part of of a SubTeam's parent team to join the SubTeam.  Arc Teams does provide a default implementation for a Join Requirement that enforces this state.</p> <p>Subteams can be queried from nearly any accessor for teams.  ArcTeams provides a few methods to do so, including a query by TeamDefinition class, matching GameplayTagQuery, or just collecting all of them.</p>"},{"location":"arcteams/concepts/team/#team-definitions","title":"Team Definitions","text":"<p>Team Definitions are a class, UArcTeamDefinition, that describes static data and UI data for the team.  The Team Definition may be reused across multiple teams, and assists in reducing replication load for the system.  </p> <p>Note</p> <p>Team Definitions cannot be dynamically created, but multiple teams can use the same definition.  </p>"},{"location":"arcteams/concepts/team/#team-states","title":"Team States","text":"<p>To assist with replicating large amounts of team data, Arc Teams provides a pair of actors that are spawned by teams to assist with replication.  </p> <p>Public Team States, <code>AArcPublicTeamState</code> is replicated to every player, and is easily accessed on clients.  Similar to the AGameState class, this is a useful construct for describing team data that everyone in the game can see, such as score, objective progression, and the like.</p> <p>Private Team States, <code>AArcPrivateTeamState</code>, is only replicated to players within that team.  This is a useful construct for replicating private team data like objectives, storing a team's private game objects, or progress toward victory.  </p> <p>Team States are created when a team is created, and destroyed when the team is destroyed.  If no TeamState class is provided in the TeamDefinition, no TeamState is created.  </p> <p>Tip</p> <p>Team States are full actors! Try putting components on them for additional functionality!</p>"},{"location":"arcteams/concepts/teamcomponents/","title":"Team Components","text":""},{"location":"arcteams/concepts/teamcomponents/#game-mode","title":"Game Mode","text":"<p>The Game Mode Component, <code>UArcTeamComponent_Gamemode</code>, is the main controller for Arc Teams.  It must be applied to your GameMode, and two functions must be overriden to provide it functionality.  </p> <p>Info</p> <p>See the Initial Setup page for more information on how to set up your GameMode to use Arc Teams!</p> <p>The GameMode Component is the authority in creating teams and allowing players to join or leave those teams.  The GameMode Component also creates SubTeams and handles allowing players to spawn on team associated start points.  </p>"},{"location":"arcteams/concepts/teamcomponents/#notable-functions-and-properties","title":"Notable Functions and Properties","text":"<ul> <li> <code>CreateTeam</code>/<code>CreateSubTeam</code> These functions create teams for the system.  They are automatically called on game init for teams defined in <code>DefaultTeams</code>, but you can call them directly to create teams dynamically. </li> <li> <code>PlayerRequestJoinTeam</code> This function is the only way for a player to join a team.  This request may fail (so check the return value!) if the JoinRequirements fail the player.   </li> </ul>"},{"location":"arcteams/concepts/teamcomponents/#game-state","title":"Game State","text":"<p>The GameState component is a helper component for replicating teams to the client.  It contains a number of accessors for getting the teams that exist that can be called from the client, as well as callbacks on both the client and server for when teams are added and removed.  </p> <p>Note</p> <p>The Game State Component is automatically added to your game state if it doesn't exist.  It is recommended that you add a GameState Component to your GameState manually, but it is not required. </p>"},{"location":"arcteams/concepts/teamcomponents/#player-state","title":"Player State","text":"<p>The PlayerState Component is the component that holds the association between Player and Team.  It contains accessors for PrimaryTeam and all SubTeams that a player is part of.  It is also the component that contains the events for when Players join and Leave teams, including SubTeams.  </p> <p>Note</p> <p>Player State Components, like the GameState Component, is automatically added to players when they join the game.  It is highly recommened that you manually add this component to your Player State class manually, but it is not required. </p>"},{"location":"home/docroadmap/","title":"Documentation Roadmap","text":"<p>This is the roadmap for documentation on this portal.  There is no schedule for when new documentation will be created, We'll get to it when we can.</p> <p>Changes and additions will be posted in <code>#plugins-announce</code> channel in discord!</p>"},{"location":"home/docroadmap/#general","title":"General","text":"<ul> <li> Puny Human Branding</li> <li> Link to Github page</li> <li> Link to Issue Tracker</li> </ul>"},{"location":"home/docroadmap/#arc-inventory","title":"Arc Inventory","text":"<ul> <li>Concepts<ul> <li> High Level</li> <li> Inventory</li> <li> Item Stack</li> <li> Item Generators</li> <li> UI</li> </ul> </li> <li>Tutorials<ul> <li> Basic Integration</li> <li> Manipulation Concepts</li> </ul> </li> <li>Integrations<ul> <li> MoveIt</li> <li> Easy Ballistics</li> </ul> </li> </ul>"},{"location":"home/docroadmap/#arc-teams","title":"Arc Teams","text":"<ul> <li>Concepts<ul> <li> High Level</li> <li> Team</li> <li> Team Components</li> <li> Team Definitions (Merged into Team)</li> <li> Team States (Merged into Team)</li> </ul> </li> <li>Tutorials<ul> <li> Basic Integration</li> <li> Squads</li> </ul> </li> <li>Integrations</li> </ul>"}]}